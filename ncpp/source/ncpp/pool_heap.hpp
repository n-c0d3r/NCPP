#pragma once

/** @file ncpp/pool_heap.hpp
 * 	@brief Implements pool heap.
*/



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Includes

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/prerequisites.hpp>

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/utilities/lref.hpp>
#include <ncpp/mem.hpp>
#include <ncpp/pac/spinlock.hpp>
#include <ncpp/utilities/unique_lock.hpp>

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/native_heap.hpp>
#include <ncpp/native_allocator.hpp>

#pragma endregion



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {

	struct pool_group;
	struct pool_chunk;
	struct pool_chunk_list;
	struct pool;
	struct in_pool_list;
	struct out_pool_list;
	struct pool_allocation;
	struct pool_allocation_list;



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct NCPP_DEFAULT_ALIGNAS pool_allocation {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct pool_group;
		friend struct pool_chunk;
		friend struct pool_chunk_list;
		friend struct pool;
		friend struct in_pool_list;
		friend struct out_pool_list;
		friend struct pool_allocation;
		friend struct pool_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		sz size_;
		pool* pool_p_;

		pool_allocation* prev_p_ = 0;
		pool_allocation* next_p_ = 0;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline sz size() const { return size_; }
		inline u8* data_p() const { return (u8*)(this + 1); }
		inline pool& pool() { return *pool_p_; }
		inline pool_allocation& prev() { return *prev_p_; }
		inline pool_allocation& next() { return *next_p_; }

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool_allocation(sz size, ncpp::pool& pool) :
			size_(size),
			pool_p_(&pool),

			prev_p_(0),
			next_p_(0)
		{



		}
		~pool_allocation() {



		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct pool_allocation_list {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct pool_group;
		friend struct pool_chunk;
		friend struct pool_chunk_list;
		friend struct pool;
		friend struct in_pool_list;
		friend struct out_pool_list;
		friend struct pool_allocation;
		friend struct pool_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		pool_allocation* head_p_;
		pool_allocation* tail_p_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool_allocation& head() { return *head_p_; }
		inline pool_allocation& tail() { return *tail_p_; }

		inline b8 is_empty() const { return head_p_ == 0; }

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool_allocation_list() :
			head_p_(0),
			tail_p_(0)
		{



		}
		inline pool_allocation_list(pool_allocation& head, pool_allocation& tail) :
			head_p_(&head),
			tail_p_(&tail)
		{



		}
		~pool_allocation_list() {



		}

		pool_allocation_list(const pool_allocation_list&) = delete;
		pool_allocation_list& operator = (const pool_allocation_list&) = delete;

		inline pool_allocation_list(pool_allocation_list&& other) :
			head_p_(other.head_p_),
			tail_p_(other.tail_p_)
		{

			other.head_p_ = 0;
			other.tail_p_ = 0;

		}
		inline pool_allocation_list& operator = (pool_allocation_list&& other)
		{

			head_p_ = other.head_p_;
			tail_p_ = other.tail_p_;

			other.head_p_ = 0;
			other.tail_p_ = 0;

			return *this;
		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline void insert(pool_allocation& s) {

			if (head_p_ == 0) {

				head_p_ = &s;
				tail_p_ = &s;

			}
			else {

				tail_p_->next_p_ = &s;
				s.prev_p_ = tail_p_;
				tail_p_ = &s;

			}

		}
		inline void erase(pool_allocation& s) {

			if (s.prev_p_ != 0) {

				s.prev_p_->next_p_ = s.next_p_;

			}
			else {

				head_p_ = s.next_p_;

			}
			if (s.next_p_ != 0) {

				s.next_p_->prev_p_ = s.prev_p_;

			}
			else {

				tail_p_ = s.prev_p_;

			}

			s.next_p_ = 0;
			s.prev_p_ = 0;

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct pool {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct pool_group;
		friend struct pool_chunk;
		friend struct pool_chunk_list;
		friend struct pool;
		friend struct in_pool_list;
		friend struct out_pool_list;
		friend struct pool_allocation;
		friend struct pool_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		sz capacity_;
		sz usage_;
		u8* data_p_;
		pool_chunk* chunk_p_;

		pool* out_prev_p_ = 0;
		pool* out_next_p_ = 0;
		pool* in_prev_p_ = 0;
		pool* in_next_p_ = 0;

		pool_allocation_list allocation_list_;
		pool_allocation_list empty_list_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline sz capacity() const { return capacity_; }
		inline sz usage() const { return usage_; }
		inline u8* data_p() const { return data_p_; }
		inline pool_chunk& chunk() { return *chunk_p_; }
		inline pool& out_prev() { return *out_prev_p_; }
		inline pool& out_next() { return *out_next_p_; }
		inline pool& in_prev() { return *in_prev_p_; }
		inline pool& in_next() { return *in_next_p_; }

		inline pool_allocation_list& allocation_list() { return allocation_list_; }

		inline b8 is_empty() const { return usage_ == 0; }

		inline u8* pushable_pointer() {

			if (!empty_list_.is_empty()) {

				return (u8*)(&(empty_list_.head()));
			}

			if (!allocation_list_.is_empty()) {

				auto& tail_allocation = allocation_list_.tail();

				return tail_allocation.data_p() + tail_allocation.size_;

			}

			return data_p_;
		}

		b8 is_pushable(sz size, sz align = NCPP_DEFAULT_ALIGN);

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool(sz capacity, pool_chunk& chunk) :
			capacity_(capacity),
			usage_(0),
			data_p_((u8*)(this + 1)),
			chunk_p_(&chunk),

			out_prev_p_(0),
			out_next_p_(0),
			in_prev_p_(0),
			in_next_p_(0)
		{



		}
		~pool() {



		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		/**
		 *	Returns aligned address shifting by the given address and align.
		 */
		inline uintptr_t align_address(uintptr_t addr, sz align)
		{
			const sz mask = align - 1;
			assert((align & mask) == 0 && "align value must be power of 2");
			return (addr + mask) & ~mask;
		}
		/**
		 *	Returns aligned pointer shifting by the given pointer and align.
		 */
		template<typename data_type>
		inline data_type* align_pointer(data_type* ptr, sz align)
		{
			const uintptr_t addr = reinterpret_cast<uintptr_t>(ptr);
			return reinterpret_cast<data_type*>(align_address(addr, align));
		}
		/**
		 *	Aligned allocates a memory block by given size and align.
		 */
		inline u8* aligned_alloc(sz size, sz align)
		{

			sz actual_size = size + sizeof(pool_allocation) + align;

			u8* raw_ptr = pushable_pointer();

			if (!empty_list_.is_empty()) {

				empty_list_.erase(empty_list_.head());

			}

			usage_ += actual_size;

			u8* aligned_ptr = align_pointer(raw_ptr, align);

			if (aligned_ptr == raw_ptr)
				aligned_ptr += align;

			pool_allocation* allocation_p = reinterpret_cast<pool_allocation*>(aligned_ptr);
			new(allocation_p) pool_allocation(actual_size, *this);



#ifdef NCPP_ENABLE_NATIVE_MEMORY_COUNTING
			increase_native_used_heap_memory(allocation_p->size());
#endif



			allocation_list_.insert(*allocation_p);

			return reinterpret_cast<u8*>(allocation_p + 1);
		}



	public:
		inline u8* allocate(sz size, sz align = NCPP_DEFAULT_ALIGN) {

			return aligned_alloc(size, align);
		}
		inline void deallocate(pool_allocation* allocation_p) {



#ifdef NCPP_ENABLE_NATIVE_MEMORY_COUNTING
			decrease_native_used_heap_memory(allocation_p->size());
#endif



			usage_ -= allocation_p->size_;
			allocation_list_.erase(*allocation_p);
			empty_list_.insert(*allocation_p);

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct in_pool_list {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct pool_group;
		friend struct pool_chunk;
		friend struct pool_chunk_list;
		friend struct pool;
		friend struct in_pool_list;
		friend struct out_pool_list;
		friend struct pool_allocation;
		friend struct pool_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		pool* head_p_;
		pool* tail_p_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool& head() { return *head_p_; }
		inline pool& tail() { return *tail_p_; }

		inline b8 is_empty() const { return head_p_ == 0; }

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline in_pool_list() :
			head_p_(0),
			tail_p_(0)
		{



		}
		inline in_pool_list(pool& head, pool& tail) :
			head_p_(&head),
			tail_p_(&tail)
		{



		}
		~in_pool_list() {



		}

		in_pool_list(const in_pool_list&) = delete;
		in_pool_list& operator = (const in_pool_list&) = delete;

		inline in_pool_list(in_pool_list&& other) :
			head_p_(other.head_p_),
			tail_p_(other.tail_p_)
		{

			other.head_p_ = 0;
			other.tail_p_ = 0;

		}
		inline in_pool_list& operator = (in_pool_list&& other)
		{

			head_p_ = other.head_p_;
			tail_p_ = other.tail_p_;

			other.head_p_ = 0;
			other.tail_p_ = 0;

			return *this;
		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline void insert(pool& s) {

			if (head_p_ == 0) {

				head_p_ = &s;
				tail_p_ = &s;

			}
			else {

				tail_p_->in_next_p_ = &s;
				s.in_prev_p_ = tail_p_;
				tail_p_ = &s;

			}

		}
		inline void erase(pool& s) {

			if (s.in_prev_p_ != 0) {

				s.in_prev_p_->in_next_p_ = s.in_next_p_;

			}
			else {

				head_p_ = s.in_next_p_;

			}
			if (s.in_next_p_ != 0) {

				s.in_next_p_->in_prev_p_ = s.in_prev_p_;

			}
			else {

				tail_p_ = s.in_prev_p_;

			}

			s.in_next_p_ = 0;
			s.in_prev_p_ = 0;

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct out_pool_list {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct pool_group;
		friend struct pool_chunk;
		friend struct pool_chunk_list;
		friend struct pool;
		friend struct in_pool_list;
		friend struct out_pool_list;
		friend struct pool_allocation;
		friend struct pool_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		pool* head_p_;
		pool* tail_p_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool& head() { return *head_p_; }
		inline pool& tail() { return *tail_p_; }

		inline b8 is_empty() const { return head_p_ == 0; }

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline out_pool_list() :
			head_p_(0),
			tail_p_(0)
		{



		}
		inline out_pool_list(pool& head, pool& tail) :
			head_p_(&head),
			tail_p_(&tail)
		{



		}
		~out_pool_list() {



		}

		out_pool_list(const out_pool_list&) = delete;
		out_pool_list& operator = (const out_pool_list&) = delete;

		inline out_pool_list(out_pool_list&& other) :
			head_p_(other.head_p_),
			tail_p_(other.tail_p_)
		{

			other.head_p_ = 0;
			other.tail_p_ = 0;

		}
		inline out_pool_list& operator = (out_pool_list&& other)
		{

			head_p_ = other.head_p_;
			tail_p_ = other.tail_p_;

			other.head_p_ = 0;
			other.tail_p_ = 0;

			return *this;
		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline void insert(pool& s) {

			if (head_p_ == 0) {

				head_p_ = &s;
				tail_p_ = &s;

			}
			else {

				tail_p_->out_next_p_ = &s;
				s.out_prev_p_ = tail_p_;
				tail_p_ = &s;

			}

		}
		inline void erase(pool& s) {

			if (s.out_prev_p_ != 0) {

				s.out_prev_p_->out_next_p_ = s.out_next_p_;

			}
			else {

				head_p_ = s.out_next_p_;

			}
			if (s.out_next_p_ != 0) {

				s.out_next_p_->out_prev_p_ = s.out_prev_p_;

			}
			else {

				tail_p_ = s.out_prev_p_;

			}

			s.out_next_p_ = 0;
			s.out_prev_p_ = 0;

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct pool_chunk {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct pool_group;
		friend struct pool_chunk;
		friend struct pool_chunk_list;
		friend struct pool;
		friend struct in_pool_list;
		friend struct out_pool_list;
		friend struct pool_allocation;
		friend struct pool_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		sz pool_capacity_;
		sz pool_count_;
		sz initialized_pool_count_;
		u8* data_p_;

		in_pool_list free_list_;
		in_pool_list available_list_;

		pool_chunk* prev_p_ = 0;
		pool_chunk* next_p_ = 0;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline sz pool_capacity() const { return pool_capacity_; }
		inline sz pool_count() const { return pool_count_; }
		inline sz initialized_pool_count() const { return initialized_pool_count_; }
		inline u8* data_p() const { return data_p_; }

		inline in_pool_list& free_list() { return free_list_; }
		inline in_pool_list& available_list() { return available_list_; }

		inline pool_chunk& prev() { return *prev_p_; }
		inline pool_chunk& next() { return *next_p_; }

		inline b8 is_empty() const { return available_list_.is_empty(); }

		b8 is_pushable(sz size, sz align = NCPP_DEFAULT_ALIGN);

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool_chunk(sz pool_capacity, sz pool_count) :
			pool_capacity_(pool_capacity),
			pool_count_(pool_count),
			data_p_((u8*)(this + 1)),

			initialized_pool_count_(0)
		{



		}
		~pool_chunk() {



		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool& pick_a_pool(sz size, sz align = NCPP_DEFAULT_ALIGN) {



			utilities::lref_t<pool> pool_ref;



			if (initialized_pool_count_ < pool_count_) {

				sz pool_size = sizeof(pool) + pool_capacity_;

				pool_ref = *((pool*)(data_p_ + pool_size * initialized_pool_count_));
				new(pool_ref.pointer()) pool(pool_capacity_, *this);

				++initialized_pool_count_;

			}
			else {

				pool_ref = free_list_.tail();
				free_list_.erase(*pool_ref);

			}



			available_list_.insert(*pool_ref);



			return *pool_ref;
		}

		inline void erase_pool(pool& s) {

			available_list_.erase(s);
			free_list_.insert(s);

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct pool_chunk_list {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct pool_group;
		friend struct pool_chunk;
		friend struct pool_chunk_list;
		friend struct pool;
		friend struct in_pool_list;
		friend struct out_pool_list;
		friend struct pool_allocation;
		friend struct pool_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		pool_chunk* head_p_;
		pool_chunk* tail_p_;

		sz count_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool_chunk& head() { return *head_p_; }
		inline pool_chunk& tail() { return *tail_p_; }

		inline b8 is_empty() const { return head_p_ == 0; }
		inline sz count() const { return count_; }

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool_chunk_list() :
			head_p_(0),
			tail_p_(0),
			count_(0)
		{



		}
		inline pool_chunk_list(pool_chunk& head, pool_chunk& tail) :
			head_p_(&head),
			tail_p_(&tail),
			count_(0)
		{



		}
		~pool_chunk_list() {

			count_ = 0;

		}

		pool_chunk_list(const pool_chunk_list&) = delete;
		pool_chunk_list& operator = (const pool_chunk_list&) = delete;

		inline pool_chunk_list(pool_chunk_list&& other) :
			head_p_(other.head_p_),
			tail_p_(other.tail_p_),
			count_(0)
		{

			other.head_p_ = 0;
			other.tail_p_ = 0;
			other.count_ = 0;

		}
		inline pool_chunk_list& operator = (pool_chunk_list&& other)
		{

			head_p_ = other.head_p_;
			tail_p_ = other.tail_p_;

			other.head_p_ = 0;
			other.tail_p_ = 0;
			other.count_ = 0;

			return *this;
		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline void insert(pool_chunk& s) {

			if (head_p_ == 0) {

				head_p_ = &s;
				tail_p_ = &s;

			}
			else {

				tail_p_->next_p_ = &s;
				s.prev_p_ = tail_p_;
				tail_p_ = &s;

			}

			++count_;

		}
		inline void erase(pool_chunk& s) {

			assert(count_ != 0 && "invalid pool chunk list");

			if (s.prev_p_ != 0) {

				s.prev_p_->next_p_ = s.next_p_;

			}
			else {

				head_p_ = s.next_p_;

			}
			if (s.next_p_ != 0) {

				s.next_p_->prev_p_ = s.prev_p_;

			}
			else {

				tail_p_ = s.prev_p_;

			}

			s.next_p_ = 0;
			s.prev_p_ = 0;

			--count_;

		}

		inline void reset() {

			head_p_ = 0;
			tail_p_ = 0;

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct pool_group {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct pool_group;
		friend struct pool_chunk;
		friend struct pool_chunk_list;
		friend struct pool;
		friend struct in_pool_list;
		friend struct out_pool_list;
		friend struct pool_allocation;
		friend struct pool_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		out_pool_list out_pool_list_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline out_pool_list& out_pool_list() { return out_pool_list_; }

		inline b8 is_empty() const { return out_pool_list_.is_empty(); }

		b8 is_pushable(sz size, sz align = NCPP_DEFAULT_ALIGN);

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline pool_group()
		{



		}
		~pool_group() {



		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	template<
		class object_type__,
		class allocator_type__ = typename NCPP_DEFAULT_ALLOCATOR_TEMPLATE<u8>,
		class lock_type__ = pac::spinlock
	>
	class pool_heap_t :
		public native_heap
	{

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct pool_group;
		friend struct pool_chunk;
		friend struct pool_chunk_list;
		friend struct pool;
		friend struct in_pool_list;
		friend struct out_pool_list;
		friend struct pool_allocation;
		friend struct pool_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Typedefs
	public:
		using allocator_type = allocator_type__;
		using lock_type = lock_type__;
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Properties
	private:
		sz max_object_count_per_pool_;
		sz pool_capacity_;
		sz pool_count_per_chunk_;
		sz min_chunk_count_;

		pool_chunk_list available_chunk_list_;
		pool_chunk_list empty_chunk_list_;

		allocator_type__ allocator_;

		lock_type__ lock_;
#pragma endregion 

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Getters
	public:
		inline sz max_object_count_per_pool() const { return max_object_count_per_pool_; }
		inline sz pool_capacity() const { return pool_capacity_; }
		inline sz pool_count_per_chunk() const { return pool_count_per_chunk_; }

		inline pool_chunk_list& available_chunk_list() { return available_chunk_list_; }
		inline pool_chunk_list& empty_chunk_list() { return empty_chunk_list_; }

		inline allocator_type__& allocator() { return allocator_; }

		inline sz min_chunk_count() const { return min_chunk_count_; }
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Constructors, Destructor and Operators
	public:
		inline pool_heap_t(
			sz max_object_count_per_pool = NCPP_DEFAULT_MAX_OBJECT_COUNT_PER_POOL,
			sz pool_count_per_chunk = NCPP_DEFAULT_POOL_COUNT_PER_CHUNK,
			sz min_chunk_count = NCPP_DEFAULT_POOL_HEAP_MIN_CHUNK_COUNT
		) :
			max_object_count_per_pool_(max_object_count_per_pool),
			pool_capacity_(max_object_count_per_pool_ * sizeof(object_type__)),
			pool_count_per_chunk_(pool_count_per_chunk),
			min_chunk_count_(min_chunk_count)
		{

			assert(min_chunk_count_ > 0 && "invalid min chunk count");

			for (sz i = 0; i < min_chunk_count_; ++i) {

				empty_chunk_list_.insert(create_chunk());

			}

		}
		~pool_heap_t() {

			clear();

		}

		inline pool_heap_t(const pool_heap_t&) = delete;
		inline pool_heap_t& operator = (const pool_heap_t&) = delete;
		inline pool_heap_t(pool_heap_t&&) = delete;
		inline pool_heap_t& operator = (pool_heap_t&&) = delete;
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Public Methods
	private:
		inline pool_chunk& create_chunk() {

			utilities::lref_t<pool_chunk> chunk_ref;



			sz pool_size = pool_capacity_ + sizeof(pool);
			sz allocation_size = sizeof(pool_chunk) + pool_size * pool_count_per_chunk_;

			pool_chunk* chunk_p = (pool_chunk*)allocator_.allocate(allocation_size);

			new(chunk_p) pool_chunk(pool_capacity_, pool_count_per_chunk_);

			chunk_ref = *chunk_p;



			return *chunk_ref;
		}

		inline pool_chunk& push_chunk() {

			utilities::lref_t<pool_chunk> chunk_ref;



			pool_chunk* chunk_p = 0;

			if (empty_chunk_list_.is_empty()) {

				chunk_p = &create_chunk();

			}
			else {

				chunk_p = &(empty_chunk_list_.tail());

				empty_chunk_list_.erase(*chunk_p);

			}

			new(chunk_p) pool_chunk(pool_capacity_, pool_count_per_chunk_);

			chunk_ref = *chunk_p;



			return *chunk_ref;
		}
		inline void release_chunk(pool_chunk& chunk) {

			sz pool_size = pool_capacity_ + sizeof(pool);
			sz allocation_size = sizeof(pool_chunk) + pool_size * pool_count_per_chunk_;

			allocator_.deallocate((u8*)&chunk, allocation_size);
		}

		inline pool& pick_a_pool(sz size, sz align = NCPP_DEFAULT_ALIGN) {



			utilities::lref_t<pool> pool_ref;

			utilities::lref_t<pool_chunk> chunk_ref;



			/// pick a chunk
			if (available_chunk_list_.is_empty()) {

				chunk_ref = push_chunk();

				available_chunk_list_.insert(*chunk_ref);

			}
			else {

				if (available_chunk_list_.tail().is_pushable(size, align)) {

					chunk_ref = available_chunk_list_.tail();

				}
				else {

					chunk_ref = push_chunk();

					available_chunk_list_.insert(*chunk_ref);

				}

			}



			/// pick a pool from the chunk
			pool_ref = chunk_ref->pick_a_pool(size, align);



			return *pool_ref;
		}



	public:
		inline u8* allocate(pool_group& group, sz n, sz align = NCPP_DEFAULT_ALIGN) {

			utilities::unique_lock_t<lock_type> lock_guard(lock_);

			sz size = n * sizeof(object_type__);

			assert(size + sizeof(pool_allocation) + align <= pool_capacity_ && "allocation size is too large to be allocated in this pool heap.");



			if (group.is_pushable(size, align)) {

				pool& s = group.out_pool_list().tail();

				return s.allocate(size, align);

			}
			else {

				pool& s = pick_a_pool(size, align);

				group.out_pool_list().insert(s);

				return s.allocate(size, align);

			}



			return 0;
		}
		inline void deallocate(pool_group& group, void* ptr) {

			utilities::unique_lock_t<lock_type> lock_guard(lock_);

			pool_allocation* allocation_p = reinterpret_cast<pool_allocation*>(ptr) - 1;



			pool& s = allocation_p->pool();
			pool_chunk& chunk = s.chunk();

			s.deallocate(allocation_p);

			if (s.is_empty()) {

				chunk.erase_pool(s);
				group.out_pool_list().erase(s);

			}

			if (chunk.is_empty()) {

				if (empty_chunk_list_.count() < min_chunk_count_) {

					available_chunk_list_.erase(chunk);
					empty_chunk_list_.insert(chunk);

				}
				else {

					available_chunk_list_.erase(chunk);

					release_chunk(chunk);

				}

			}

		}
		inline void clear_group(pool_group& group) {

			utilities::unique_lock_t<lock_type> lock_guard(lock_);

			pool* pool_p = &(group.out_pool_list().tail());
			while (pool_p != 0) {

				pool* prev_pool_p = &(pool_p->out_prev());

				pool_chunk& chunk = pool_p->chunk();

				pool_p->chunk().erase_pool(*pool_p);

				if (chunk.is_empty()) {

					if (empty_chunk_list_.count() < min_chunk_count_) {

						available_chunk_list_.erase(chunk);
						empty_chunk_list_.insert(chunk);

					}
					else {

						available_chunk_list_.erase(chunk);

						release_chunk(chunk);

					}

				}

				pool_p = prev_pool_p;

			}

		}

		inline void clear() {

			utilities::unique_lock_t<lock_type> lock_guard(lock_);

			pool_chunk* chunk_p = &(empty_chunk_list_.head());
			while (chunk_p != 0) {

				pool_chunk* next_chunk_p = &(chunk_p->next());

				release_chunk(*chunk_p);

				chunk_p = next_chunk_p;

			}
			empty_chunk_list_.reset();

			chunk_p = &(available_chunk_list_.head());
			while (chunk_p != 0) {

				pool_chunk* next_chunk_p = &(chunk_p->next());

				release_chunk(*chunk_p);

				chunk_p = next_chunk_p;

			}
			empty_chunk_list_.reset();
		}
#pragma endregion

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Allocators
	template <class value_type__, class pool_heap_type__ = pool_heap_t<value_type__>>
	class NCPP_DEFAULT_ALIGNAS pool_allocator_t :
		public native_allocator_t<value_type__>
	{

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Typedefs
	public:
		using size_type = sz;
		using difference_type = ptrdiff_t;
		using pointer = value_type__*;
		using const_pointer = const value_type__*;
		using reference = value_type__&;
		using const_reference = const value_type__&;
		using value_type = value_type__;
		using pool_heap_type = pool_heap_type__;
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Properties
	private:
		utilities::lref_t<pool_heap_type> pool_heap_ref_;

		utilities::lref_t<pool_group> pool_group_ref_;
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Getters
	public:
		inline pool_heap_type& pool_heap() { return *pool_heap_ref_; }
		inline const pool_heap_type& pool_heap() const { return *pool_heap_ref_; }

		inline pool_group& group() { return *pool_group_ref_; }
		inline const pool_group& group() const { return *pool_group_ref_; }

		inline b8 is_null() const { return pool_heap_ref_.is_null(); }
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Constructors, Destructor and Operators
	public:
		inline pool_allocator_t() :
			pool_heap_ref_(),
			pool_group_ref_()
		{



		}
		inline pool_allocator_t(pool_heap_type& pool_heap, pool_group& group) :
			pool_heap_ref_(pool_heap),
			pool_group_ref_(group)
		{



		}
		inline pool_allocator_t(const pool_allocator_t& other) :
			pool_allocator_t((pool_heap_type&)(other.pool_heap()), (pool_group&)(other.group()))
		{



		}

		inline pool_allocator_t<value_type, pool_heap_type>& operator=(const pool_allocator_t& other) {

			pool_heap_ref_ = other.pool_heap_ref_;
			pool_group_ref_ = other.pool_group_ref_;

			return *this;
		}
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Methods
	private:
		inline pointer internal_allocate(size_type n, sz align = NCPP_DEFAULT_ALIGN) {

			assert(!pool_heap_ref_.is_null() && "tagged heap is null");

			return (pointer)(pool_heap_ref_->allocate(*pool_group_ref_, n, align));
		}
		inline void internal_deallocate(pointer ptr, sz n = 1) {
			
			assert(!pool_heap_ref_.is_null() && "tagged heap is null");

			pool_heap_ref_->deallocate(*pool_group_ref_, ptr);
		}



	protected:
		void* abstract_allocate(size_type size, sz align = NCPP_DEFAULT_ALIGN) {

			return (void*)internal_allocate(size / sizeof(value_type__), align);
		}
		void abstract_deallocate(void* ptr, sz size = sizeof(value_type__)) {

			internal_deallocate((pointer)ptr, size / sizeof(value_type__));
		}



	public:
		inline pointer   allocate(size_type n, sz align = NCPP_DEFAULT_ALIGN) {

			return internal_allocate(n, align);
		}

		inline void      deallocate(pointer ptr, sz n = 1) {

			internal_deallocate(ptr, n);
		}

		inline pointer           address(reference x) const { return &x; }
		inline const_pointer     address(const_reference x) const { return &x; }
		inline void              destroy(pointer p) { p->~value_type(); }

		inline size_type         max_size() const { return size_t(-1); }

		template <class U>
		struct rebind { typedef pool_allocator_t<U, pool_heap_type> other; };
#pragma endregion

	};
#pragma endregion

}

