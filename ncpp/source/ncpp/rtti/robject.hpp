#pragma once

/**
 *  @file ncpp/rtti/robject.hpp
 *  @brief Implements reflected object.
 */



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Includes

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/prerequisites.hpp>

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/utilities/.hpp>
#include <ncpp/containers/.hpp>
#include <ncpp/dop/.hpp>
#include <ncpp/pac/.hpp>
#include <ncpp/iostream.hpp>

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/rtti/rclass.hpp>

#pragma endregion 



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {

    namespace rtti {

        class robject_i;



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        /**
         *  Indicates a class need to be reflected.
         *  Must be added first in class body.
         */
#define NCPP_RCLASS(ClassName) \
        private: \
            using current_rclass = ClassName;\
            ncpp::rtti::robject_constructor_begin_scope __##ClassName##_constructor_begin_scope__; \
        public: \
            virtual ncpp::rtti::rclass_t<ncpp::rtti::robject_i> get_class() const { \
                return ncpp::rtti::rclass_t<ClassName>().rebind_t<ncpp::rtti::robject_i>(); \
            } \
            static inline ncpp::rtti::rclass_t<ClassName> get_static_class() { \
                return ncpp::rtti::rclass_t<ClassName>(); \
            } \
            inline ClassName& instantiate() const {\
                ClassName& result = (ClassName&)get_class().create_instance();\
                result = *this;\
                return result;\
            }\
            inline ncpp::utilities::native_shared_ptr_t<ClassName> shared_instantiate() const {\
                ncpp::utilities::native_shared_ptr_t<ClassName> result = ncpp::utilities::native_shared_ptr_cast_t<ClassName>(get_class().create_shared_instance());\
                *result = *this;\
                return result;\
            }\
            inline ncpp::utilities::native_unique_ptr_t<ClassName> unique_instantiate() const {\
                ncpp::utilities::native_unique_ptr_t<ClassName> result = ncpp::utilities::native_unique_ptr_cast_t<ClassName>(get_class().create_unique_instance());\
                *result = *this;\
                return result;\
            }\
        private:  

         /**
          *  Setups the constructing scope of a reflected class.
          *  Must be added first in constructor body.
          */
#define NCPP_RCSCOPE(ClassName) \
        ncpp::rtti::robject_constructor_end_scope __robject_constructor_end_scope__(*this, *(__##ClassName##_constructor_begin_scope__.prev_robject_ref));

          /**
           *  Declares a reflected member variable.
           */
#define NCPP_RCVARIABLE(MemberType, MemberName, ...) \
        ncpp::rtti::robject_member_handle MemberName##_member_handle; \
        MemberType MemberName;\
        char MemberName##_name_cstr[sizeof(#MemberName)] = #MemberName;\
        using MemberName##_args_type = typename ncpp::rtti::robject_member_args_t<__VA_ARGS__>;\
        MemberName##_args_type MemberName##_args = {__VA_ARGS__}; \
        using MemberName##_reflecter_type = ncpp::rtti::robject_variable_reflecter_t<\
            current_rclass, \
            MemberType, \
            decltype(&current_rclass::MemberName##_name_cstr),\
            &current_rclass::MemberName##_name_cstr,\
            decltype(&current_rclass::MemberName##_args),\
            &current_rclass::MemberName##_args,\
            decltype(&current_rclass::MemberName##_member_handle),\
            &current_rclass::MemberName##_member_handle,\
            decltype(&current_rclass::MemberName),\
            &current_rclass::MemberName\
        >; \
        friend class MemberName##_reflecter_type; \
        MemberName##_reflecter_type MemberName##_reflecter;

           /**
            *  Declares a reflected member function.
            */
#define NCPP_RCFUNCTION(MemberFunctionType, MemberName,...) \
        ncpp::rtti::robject_member_handle MemberName##_member_handle; \
        using MemberName##_type = MemberFunctionType; \
        MemberName##_type MemberName; \
        ncpp::rtti::robject_function_executer_t<\
            MemberName##_type \
        > MemberName##_executer; \
        char MemberName##_name_cstr[sizeof(#MemberName)] = #MemberName;\
        typename ncpp::rtti::robject_member_args_t<__VA_ARGS__> MemberName##_args = {__VA_ARGS__}; \
        typename std::function<MemberFunctionType> MemberName##_functor; \
        using MemberName##_reflecter_type = ncpp::rtti::robject_function_reflecter_t<\
            current_rclass, \
            MemberFunctionType, \
            decltype(&current_rclass::MemberName##_name_cstr),\
            &current_rclass::MemberName##_name_cstr,\
            decltype(&current_rclass::MemberName##_args),\
            &current_rclass::MemberName##_args,\
            decltype(&current_rclass::MemberName##_functor),\
            &current_rclass::MemberName##_functor,\
            decltype(&current_rclass::MemberName##_member_handle),\
            &current_rclass::MemberName##_member_handle,\
            decltype(&current_rclass::MemberName##_executer), \
            &current_rclass::MemberName##_executer, \
            decltype(&current_rclass::MemberName),\
            &current_rclass::MemberName\
        >; \
        friend class MemberName##_reflecter_type; \
        MemberName##_reflecter_type MemberName##_reflecter;



            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



            /**
             *  Stores member's arguments.
             */
        template<sz... args__>
        using robject_member_args_t = typename std::array<sz, sizeof... (args__)>;



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        /**
         *  Gets the current constructing object.
         */
        robject_i& current_constructing_object();



        class robject_constructor_begin_scope;
        class robject_constructor_end_scope;



        /**
         *  .
         */
        class robject_constructor_begin_scope {

            friend class robject_i;

        public:
            utilities::lref_t<robject_i> prev_robject_ref;

        public:
            robject_constructor_begin_scope();
            ~robject_constructor_begin_scope();

        };

        /**
         *  .
         */
        class robject_constructor_end_scope {

            friend class robject_i;

        public:
            utilities::lref_t<robject_i> prev_robject_ref;

        public:
            robject_constructor_end_scope(robject_i& robject, robject_i& prev_robject);
            inline robject_constructor_end_scope() :
                robject_constructor_end_scope(*utilities::lref_t<robject_i>(), *utilities::lref_t<robject_i>())
            {}
            ~robject_constructor_end_scope();

        };



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        template<
            class object_type__,
            typename variable_type__,
            typename name_member_ptr_type,
            name_member_ptr_type name_member_ptr,
            typename args_member_ptr_type,
            args_member_ptr_type args_member_ptr,
            typename member_handle_ptr_type,
            member_handle_ptr_type member_handle_ptr,
            typename member_ptr_type,
            member_ptr_type member_ptr
        >
        class robject_variable_reflecter_t
        {

        public:
            robject_variable_reflecter_t();
            ~robject_variable_reflecter_t();

        };



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        template<
            class object_type__,
            typename function_type__,
            typename name_member_ptr_type,
            name_member_ptr_type name_member_ptr,
            typename args_member_ptr_type,
            args_member_ptr_type args_member_ptr,
            typename functor_member_ptr_type,
            functor_member_ptr_type functor_member_ptr,
            typename member_handle_ptr_type,
            member_handle_ptr_type member_handle_ptr,
            typename member_executer_ptr_type,
            member_executer_ptr_type member_executer_ptr,
            typename member_ptr_type,
            member_ptr_type member_ptr
        >
        class robject_function_reflecter_t
        {

        public:
            typedef void* executer_type;



        public:
            robject_function_reflecter_t();
            ~robject_function_reflecter_t();

            template<b8 is_void_return__>
            struct executer_get_t;

        };



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        template<
            typename function_type__,
            b8 is_void_return__
        >
        struct robject_function_executer_impl_t {

        };



        template<typename function_type__>
        using robject_function_executer_t = typename robject_function_executer_impl_t<
            function_type__,
            std::is_same_v<
                typename utilities::function_traits_t<function_type__>::return_type,
                void
            >
        >;



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        /**
         *  Stores member's arguments pointer, robject pointer and member pointer.
         */
        struct robject_member_handle {

            struct args_array_type {

                sz* head_arg_p = 0;
                sz arg_count = 0;

                inline const sz& head() const {

                    return *head_arg_p;
                }
                inline const sz& tail() const {

                    return *(head_arg_p + arg_count - 1);
                }
                inline const sz* begin() const {

                    return head_arg_p;
                }
                inline const sz* end() const {

                    return head_arg_p + arg_count;
                }

            };



            using logger_func_ptr_type = void(*)(
                std::ostream& os,
                const ostream_input_t<
                robject_member_handle
                >& input
                );



            args_array_type args_array;
            b8 is_function = 0;
            logger_func_ptr_type logger_func_ptr = 0;
            sz member_offset = 0;

            inline void* member_p() const {

                return reinterpret_cast<void*>(
                    reinterpret_cast<sz>(this)
                    + member_offset
                    );
            }



            inline robject_member_handle() {


            }
            inline robject_member_handle(const robject_member_handle& other) :
                args_array(other.args_array),
                is_function(other.is_function),
                logger_func_ptr(other.logger_func_ptr),
                member_offset(other.member_offset)
            {



            }
            inline robject_member_handle& operator = (const robject_member_handle& other) {

                args_array = other.args_array;
                is_function = other.is_function;
                logger_func_ptr = other.logger_func_ptr;
                member_offset = other.member_offset;

                return *this;
            }



            friend inline std::ostream& operator << (
                std::ostream& os,
                const ostream_input_t<
                robject_member_handle
                >& input
                )
            {

                input.first.logger_func_ptr(os, input);

                return os;
            }

            friend inline std::ostream& operator << (std::ostream& os, const robject_member_handle& member_handle)
            {

                os << ostream_input_t<robject_member_handle> { member_handle, 0 };

                return os;
            }



            /**
             *  The type that is recorrected by the rules:
             *      1. if type__ is function type, return std::function<type__>.
             *      2. if type__ is not function type, return type__.
             */
            template<typename type__>
            using recorrected_type_t = typename utilities::nth_template_arg_t<
                utilities::is_function_t<type__>::value,
                type__,
                typename robject_function_executer_t<type__>
            >::type;



            /**
             *  Casts to recorrected type__.
             */
            template<typename type__>
            inline recorrected_type_t<type__>& to_t() {

                return *reinterpret_cast<recorrected_type_t<type__>*>(member_p());
            }

            /**
             *  Casts to recorrected type__.
             */
            template<typename type__>
            inline recorrected_type_t<const type__>& to_t() const {

                return *reinterpret_cast<recorrected_type_t<const type__>*>(member_p());
            }



            /**
             *  Sets the value of member data from other data.
             */
            template<typename type__>
            inline robject_member_handle& operator = (
                type__&& other
                ) {

                static_assert(!utilities::is_function_t<type__>::value && "type__ must not be function type");
                assert(!is_function && "this is not function");

                to_t<std::remove_reference<type__>::type>() = std::forward<type__>(other);

                return *this;
            }



            /**
             *  Checks if the value of member data equal to other data.
             */
            template<typename type__>
            inline b8 operator == (type__&& other) {

                static_assert(!utilities::is_function_t<type__>::value && "type__ must not be function type");
                assert(!is_function && "this is not function");

                return to_t<std::remove_reference<type__>::type>() == std::forward<type__>(other);
            }

            /**
             *  Checks if the value of member data not equal to other data.
             */
            template<typename type__>
            inline b8 operator != (type__&& other) {

                static_assert(!utilities::is_function_t<type__>::value && "type__ must not be function type");
                assert(!is_function && "this is not function");

                return to_t<std::remove_reference<type__>::type>() != std::forward<type__>(other);
            }

            /**
             *  Checks if the value of member data greater than other data.
             */
            template<typename type__>
            inline b8 operator > (type__&& other) {

                static_assert(!utilities::is_function_t<type__>::value && "type__ must not be function type");
                assert(!is_function && "this is not function");

                return to_t<std::remove_reference<type__>::type>() > std::forward<type__>(other);
            }

            /**
             *  Checks if the value of member data less than other data.
             */
            template<typename type__>
            inline b8 operator < (type__&& other) {

                static_assert(!utilities::is_function_t<type__>::value && "type__ must not be function type");
                assert(!is_function && "this is not function");

                return to_t<std::remove_reference<type__>::type>() < std::forward<type__>(other);
            }

            /**
             *  Checks if the value of member data greater than or equal to other data.
             */
            template<typename type__>
            inline b8 operator >= (type__&& other) {

                static_assert(!utilities::is_function_t<type__>::value && "type__ must not be function type");
                assert(!is_function && "this is not function");

                return to_t<std::remove_reference<type__>::type>() >= std::forward<type__>(other);
            }

            /**
             *  Checks if the value of member data less than or equal to other data.
             */
            template<typename type__>
            inline b8 operator <= (type__&& other) {

                static_assert(!utilities::is_function_t<type__>::value && "type__ must not be function type");
                assert(!is_function && "this is not function");

                return to_t<std::remove_reference<type__>::type>() <= std::forward<type__>(other);
            }

        };



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        template<
            typename map_iterator_type__ = typename containers::native_unordered_map_t<containers::native_string, sz>::iterator
        >
        struct robject_iterator_t {

            const robject_i* robject_p = 0;
            map_iterator_type__ map_iterator;



            inline containers::native_string name() const {

                return map_iterator->first;
            }



            inline robject_iterator_t& operator ++ () {

                ++map_iterator;

                return *this;
            }
            inline robject_iterator_t& operator -- () {

                --map_iterator;

                return *this;
            }



            inline b8 operator == (const robject_iterator_t& other) const {

                return map_iterator == other.map_iterator;
            }
            inline b8 operator != (const robject_iterator_t& other) const {

                return map_iterator != other.map_iterator;
            }



            inline robject_member_handle& operator * () {

                return *reinterpret_cast<robject_member_handle*>(
                    reinterpret_cast<sz>(robject_p)
                    + map_iterator->second
                    );
            }
            inline const robject_member_handle& operator * () const {

                return *reinterpret_cast<const robject_member_handle*>(
                    reinterpret_cast<sz>(robject_p)
                    + map_iterator->second
                    );
            }



            inline robject_member_handle* operator -> () {

                return reinterpret_cast<robject_member_handle*>(
                    reinterpret_cast<sz>(robject_p)
                    + map_iterator->second
                    );
            }
            inline const robject_member_handle* operator -> () const {

                return reinterpret_cast<const robject_member_handle*>(
                    reinterpret_cast<sz>(robject_p)
                    + map_iterator->second
                    );
            }

        };



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        /**
         *  Reflected object interface.
         */
        class robject_i {

            NCPP_RCLASS(robject_i);

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

        public:
            using name_to_member_handle_offset_map_type = typename containers::native_unordered_map_t<containers::native_string, sz>;

            using iterator = robject_iterator_t<name_to_member_handle_offset_map_type::iterator>;
            using const_iterator = robject_iterator_t<name_to_member_handle_offset_map_type::const_iterator>;

            friend class robject_constructor_scope;

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

        private:
            name_to_member_handle_offset_map_type name_to_member_handle_offset_map_;

        public:
            inline iterator begin() {

                return { this, name_to_member_handle_offset_map_.begin() };
            }
            inline const_iterator begin() const {

                return { this, name_to_member_handle_offset_map_.cbegin() };
            }
            inline const_iterator cbegin() const {

                return { this, name_to_member_handle_offset_map_.cbegin() };
            }

            inline iterator end() {

                return { this, name_to_member_handle_offset_map_.end() };
            }
            inline const_iterator end() const {

                return { this, name_to_member_handle_offset_map_.cend() };
            }
            inline const_iterator cend() const {

                return { this, name_to_member_handle_offset_map_.cend() };
            }

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Constructors, Destructor and Operators
        public:
            robject_i();
            virtual ~robject_i();



        public:
            /**
             *  Gets member handle by name.
             */
            inline robject_member_handle& operator [] (const containers::native_string& member_name) {

                if (name_to_member_handle_offset_map_.find(member_name) != name_to_member_handle_offset_map_.end())
                    return *reinterpret_cast<robject_member_handle*>(
                        reinterpret_cast<sz>(this)
                        + name_to_member_handle_offset_map_.find(member_name)->second
                        );

                return *utilities::lref_t<robject_member_handle>();
            }
            /**
             *  Gets member handle by name.
             */
            inline const robject_member_handle& operator [] (const containers::native_string& member_name) const {

                if (name_to_member_handle_offset_map_.find(member_name) != name_to_member_handle_offset_map_.end())
                    return *reinterpret_cast<const robject_member_handle*>(
                        reinterpret_cast<sz>(this)
                        + name_to_member_handle_offset_map_.find(member_name)->second
                        );

                return *utilities::lref_t<robject_member_handle>();
            }
#pragma endregion

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Methods
        public:
            /**
             *  Checks if the robject has member named <member_name>
             */
            inline b8 is_has_member(const containers::native_string& member_name) const {

                if (name_to_member_handle_offset_map_.find(member_name) != name_to_member_handle_offset_map_.end())
                    return true;

                return false;
            }

            /**
             *  Adds a member handle into name_to_member_handle_map_.
             */
            inline void add_member_handle(const containers::native_string& member_name, const robject_member_handle& handle) {

                assert(!is_has_member(member_name) && "member already existed");

                name_to_member_handle_offset_map_[member_name] = reinterpret_cast<sz>(&handle) - reinterpret_cast<sz>(this);

            }

            /**
             *  Gets reflected variable by name.
             */
            template<typename variable_type__>
            inline variable_type__& var_t(const containers::native_string& member_name) {

                return at(member_name).to_t<variable_type__>();
            }

            /**
             *  Gets reflected variable by name.
             */
            template<typename variable_type__>
            inline const variable_type__& var_t(const containers::native_string& member_name) const {

                return at(member_name).to_t<variable_type__>();
            }

            /**
             *  Gets reflected function by name.
             */
            template<typename function_type__>
            inline const robject_function_executer_t<function_type__>& func_t(const containers::native_string& member_name) const {

                return at(member_name).to_t<function_type__>();
            }

            /**
             *  Gets member handle by name.
             */
            inline robject_member_handle& at(const containers::native_string& member_name) {

                if (name_to_member_handle_offset_map_.find(member_name) != name_to_member_handle_offset_map_.end())
                    return *reinterpret_cast<robject_member_handle*>(
                        reinterpret_cast<sz>(this)
                        + name_to_member_handle_offset_map_.find(member_name)->second
                        );

                return *utilities::lref_t<robject_member_handle>();
            }
            /**
             *  Gets member handle by name.
             */
            inline const robject_member_handle& at(const containers::native_string& member_name) const {

                if (name_to_member_handle_offset_map_.find(member_name) != name_to_member_handle_offset_map_.end())
                    return *reinterpret_cast<const robject_member_handle*>(
                        reinterpret_cast<sz>(this)
                        + name_to_member_handle_offset_map_.find(member_name)->second
                        );

                return *utilities::lref_t<robject_member_handle>();
            }
#pragma endregion

        };




        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        template<
            class object_type__,
            typename variable_type__,
            typename name_member_ptr_type,
            name_member_ptr_type name_member_ptr,
            typename args_member_ptr_type,
            args_member_ptr_type args_member_ptr,
            typename member_handle_ptr_type,
            member_handle_ptr_type member_handle_ptr,
            typename member_ptr_type,
            member_ptr_type member_ptr
        >
        robject_variable_reflecter_t<
            object_type__,
            variable_type__,
            name_member_ptr_type,
            name_member_ptr,
            args_member_ptr_type,
            args_member_ptr,
            member_handle_ptr_type,
            member_handle_ptr,
            member_ptr_type,
            member_ptr
        >::robject_variable_reflecter_t() {

            object_type__& robj = (object_type__&)current_constructing_object();

            robject_member_handle& member_handle = robj.*member_handle_ptr;

            member_handle.args_array = {
                (robj.*args_member_ptr).data(),
                (robj.*args_member_ptr).size()
            };
            member_handle.is_function = 0;
            member_handle.member_offset = reinterpret_cast<sz>(&(robj.*member_ptr)) - reinterpret_cast<sz>(&member_handle);

            member_handle.logger_func_ptr = [](
                std::ostream& os,
                const ostream_input_t<
                robject_member_handle
                >& input
                ) {

                    safe_ostream_with_tab_t<std::ostream, variable_type__>(
                        os,
                        {
                            *reinterpret_cast<variable_type__*>(input.first.member_p()),
                            input.second
                        }
                    );

            };



            robj.add_member_handle(robj.*name_member_ptr, member_handle);

        }

        template<
            class object_type__,
            typename variable_type__,
            typename name_member_ptr_type,
            name_member_ptr_type name_member_ptr,
            typename args_member_ptr_type,
            args_member_ptr_type args_member_ptr,
            typename member_handle_ptr_type,
            member_handle_ptr_type member_handle_ptr,
            typename member_ptr_type,
            member_ptr_type member_ptr
        >
        robject_variable_reflecter_t<
            object_type__,
            variable_type__,
            name_member_ptr_type,
            name_member_ptr,
            args_member_ptr_type,
            args_member_ptr,
            member_handle_ptr_type,
            member_handle_ptr,
            member_ptr_type,
            member_ptr
        >::~robject_variable_reflecter_t() {



        }



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        template<
            class object_type__,
            typename function_type__,
            typename name_member_ptr_type,
            name_member_ptr_type name_member_ptr,
            typename args_member_ptr_type,
            args_member_ptr_type args_member_ptr,
            typename functor_member_ptr_type,
            functor_member_ptr_type functor_member_ptr,
            typename member_handle_ptr_type,
            member_handle_ptr_type member_handle_ptr,
            typename member_executer_ptr_type,
            member_executer_ptr_type member_executer_ptr,
            typename member_ptr_type,
            member_ptr_type member_ptr
        >
        robject_function_reflecter_t<
            object_type__,
            function_type__,
            name_member_ptr_type,
            name_member_ptr,
            args_member_ptr_type,
            args_member_ptr,
            functor_member_ptr_type,
            functor_member_ptr,
            member_handle_ptr_type,
            member_handle_ptr,
            member_executer_ptr_type,
            member_executer_ptr,
            member_ptr_type,
            member_ptr
        >::robject_function_reflecter_t() {

            object_type__& robj = (object_type__&)current_constructing_object();

            using function_traits = typename utilities::function_traits_t<function_type__>;



            using executer_type = typename robject_function_executer_t<function_type__>;

            executer_type& rfunc_executer = robj.*member_executer_ptr;

            rfunc_executer.inv_object_offset = reinterpret_cast<sz>(&rfunc_executer) - reinterpret_cast<sz>(&robj);
            rfunc_executer.bind_t<
                object_type__,
                member_ptr_type,
                member_ptr
            >();



            robject_member_handle& member_handle = robj.*member_handle_ptr;
            member_handle.args_array = {
                (robj.*args_member_ptr).data(),
                (robj.*args_member_ptr).size()
            };
            member_handle.is_function = 1;
            member_handle.member_offset = reinterpret_cast<sz>(&rfunc_executer) - reinterpret_cast<sz>(&member_handle);

            member_handle.logger_func_ptr = [](
                std::ostream& os,
                const ostream_input_t<
                robject_member_handle
                >& input
                ) {

                    os << typeid(function_type__).name();

            };



            robj.add_member_handle(robj.*name_member_ptr, member_handle);

        }

        template<
            class object_type__,
            typename function_type__,
            typename name_member_ptr_type,
            name_member_ptr_type name_member_ptr,
            typename args_member_ptr_type,
            args_member_ptr_type args_member_ptr,
            typename functor_member_ptr_type,
            functor_member_ptr_type functor_member_ptr,
            typename member_handle_ptr_type,
            member_handle_ptr_type member_handle_ptr,
            typename member_executer_ptr_type,
            member_executer_ptr_type member_executer_ptr,
            typename member_ptr_type,
            member_ptr_type member_ptr
        >
        robject_function_reflecter_t<
            object_type__,
            function_type__,
            name_member_ptr_type,
            name_member_ptr,
            args_member_ptr_type,
            args_member_ptr,
            functor_member_ptr_type,
            functor_member_ptr,
            member_handle_ptr_type,
            member_handle_ptr,
            member_executer_ptr_type,
            member_executer_ptr,
            member_ptr_type,
            member_ptr
        >::~robject_function_reflecter_t() {



        }



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        template<
            typename return_type__,
            typename... arg_types__
        >
        struct robject_function_executer_impl_t <
            return_type__(arg_types__...),
            true
        >
        {

            using function_type = typename return_type__(robject_i* obj_p, arg_types__...);
            using functor_type = typename std::function<typename return_type__(arg_types__...)>;

            sz inv_object_offset = 0;
            function_type* func_ptr = 0;



            inline robject_i* object_p() const {

                return reinterpret_cast<robject_i*>(
                    reinterpret_cast<sz>(this) - inv_object_offset
                    );
            }

            inline return_type__ operator () (arg_types__... args) const {

                func_ptr(object_p(), std::forward<arg_types__>(args)...);
            }

            template<
                class robject_type__,
                typename member_ptr_type,
                member_ptr_type member_ptr
            >
            inline void bind_t() {

                func_ptr = [](robject_i* obj_p, arg_types__... args)->return_type__ {

                    (((robject_type__*)obj_p)->*member_ptr)(std::forward<arg_types__>(args)...);

                };

            }



            inline functor_type to_functor() const {

                robject_i* obj_p = object_p();

                return [=](arg_types__... args) -> return_type__ {

                    func_ptr(obj_p, std::forward<arg_types__>(args)...);
                };
            }

        };



        template<
            typename return_type__,
            typename... arg_types__
        >
        struct robject_function_executer_impl_t <
            return_type__(arg_types__...),
            false
        >
        {

            using function_type = typename return_type__(robject_i* obj_p, arg_types__...);
            using functor_type = typename std::function<typename return_type__(arg_types__...)>;

            sz inv_object_offset = 0;
            function_type* func_ptr = 0;



            inline robject_i* object_p() const {

                return reinterpret_cast<robject_i*>(
                    reinterpret_cast<sz>(this) - inv_object_offset
                    );
            }

            inline return_type__ operator () (arg_types__... args) const {

                return func_ptr(object_p(), std::forward<arg_types__>(args)...);
            }

            template<
                class robject_type__,
                typename member_ptr_type,
                member_ptr_type member_ptr
            >
            inline void bind_t() {

                func_ptr = [](robject_i* obj_p, arg_types__... args)->return_type__ {

                    return (((robject_type__*)obj_p)->*member_ptr)(std::forward<arg_types__>(args)...);

                };

            }



            inline functor_type to_functor() const {

                robject_i* obj_p = object_p();

                return [=](arg_types__... args) -> return_type__ {

                    return func_ptr(obj_p, std::forward<arg_types__>(args)...);
                };
            }

        };



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        inline std::ostream& operator << (
            std::ostream& os,
            const ostream_input_t<
            robject_i
            >& input
            )
        {

            if (input.second > NCPP_MAX_TAB_COUNT) {

                os << "...";

                return os;
            }

            os << "{" << std::endl;

            b8 is_first_member = true;

            for (auto member_handle_it = input.first.begin(); member_handle_it != input.first.end(); ++member_handle_it) {

                if (!is_first_member) {

                    os << ",";
                    os << std::endl;

                }

                is_first_member = false;

                for (u32 j = 0; j < (input.second + 1) * NCPP_TAB_SIZE; ++j) {

                    os << " ";

                }

                os << '"' << member_handle_it.name() << '"' << ": ";
                safe_ostream_with_tab_t<std::ostream, decltype(*member_handle_it)>(os, { *member_handle_it, input.second + 1 });

            }

            os << std::endl;

            for (u32 j = 0; j < (input.second) * NCPP_TAB_SIZE; ++j) {

                os << " ";

            }
            os << "}";

            return os;
        }

        inline std::ostream& operator << (std::ostream& os, const robject_i& obj)
        {

            os << ostream_input_t<robject_i> { obj, 0 };

            return os;
        }

        inline std::ostream& operator << (
            std::ostream& os,
            const ostream_input_t<
                rtti::robject_i*
            >& input
            )
        {

            if (input.first == 0) {

                os << "null";

            }
            else {

                safe_ostream_with_tab_t<std::ostream, rtti::robject_i>(os, { *input.first, input.second });

            }

            return os;
        }

    }

}