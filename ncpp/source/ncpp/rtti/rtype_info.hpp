#pragma once

/** @file ncpp/rtti/robject.hpp
*	@brief Implements reflected object.
*/



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Includes

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/prerequisites.hpp>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/iostream.hpp>
#include <ncpp/utilities/is_function.hpp>

#pragma endregion



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {

	namespace rtti {

		template<typename allocator_type__ = NCPP_DEFAULT_ALLOCATOR>
		struct rtype_info_t {

		public:
			using allocator_type = allocator_type__;

			template<typename type__>
			using T_type_t = utilities::nth_template_arg_t<
				static_cast<u8>(!std::is_same_v<std::remove_pointer_t<type__>, type__>)
				+ static_cast<u8>(!std::is_same_v<std::remove_reference_t<type__>, type__>) * 2,
				std::remove_const_t<type__>,
				std::remove_pointer_t<std::remove_const_t<type__>>,
				std::remove_reference_t<std::remove_const_t<type__>>
			>::type;



		public:
			mutable rtype_info_t* T_info_p = 0;
			mutable sz hash_code = 0;
			mutable eastl::string name;
			mutable bool is_pointer = false;
			mutable bool is_lvalue_reference = false;
			mutable bool is_rvalue_reference = false;
			mutable bool is_constant = false;

			mutable allocator_type allocator;



		public:
			sz T_hash_code() const {

				if (T_info_p)
					return T_info_p->hash_code;

				return hash_code;
			}
			template<typename type__>
			static inline sz T_hash_code_t() {

				if (std::is_const_v<type__>)
					return typeid(std::remove_const_t<type__>).hash_code();
				if (std::is_reference_v<type__>)
					return typeid(std::remove_reference_t<type__>).hash_code();

				return typeid(type__).hash_code();
			}



		private:
			inline rtype_info_t(
				rtype_info_t* T_info_p,
				sz hash_code,
				const eastl::string& name,
				bool is_pointer,
				bool is_lvalue_reference,
				bool is_rvalue_reference,
				bool is_constant,
				const allocator_type& allocator
			) :
				T_info_p(T_info_p),
				hash_code(hash_code),
				name(name),
				is_pointer(is_pointer),
				is_lvalue_reference(is_lvalue_reference),
				is_rvalue_reference(is_rvalue_reference),
				is_constant(is_constant),
				allocator(allocator)
			{



			}

		public:
			rtype_info_t() {



			}
			~rtype_info_t() {

				if (T_info_p) {

					T_info_p->release();

				}

			}
			rtype_info_t(const rtype_info_t&) = default;
			rtype_info_t& operator = (const rtype_info_t&) = default;
			rtype_info_t(rtype_info_t&&) = default;
			rtype_info_t& operator = (rtype_info_t&&) = default;



		private:
			template<typename type__>
			static rtype_info_t* create_internal_t(allocator_type__& alloc) {

				rtype_info_t* T_info_p = 0;
				
				if (!std::is_same_v<type__, T_type_t<type__>>) {

					T_info_p = create_internal_t<T_type_t<type__>>(alloc);

				}

				return new(
					reinterpret_cast<rtype_info_t*>(
						alloc.allocate(sizeof(rtype_info_t), 0)
					)
				) rtype_info_t(
					T_info_p,
					typeid(type__).hash_code(),
					typeid(type__).name(),
					std::is_pointer_v<type__>,
					std::is_lvalue_reference_v<type__>,
					std::is_rvalue_reference_v<type__>,
					std::is_const_v<type__>,
					alloc
				);
			}

		public:
			template<typename type__>
			static inline rtype_info_t* create_t(allocator_type__& alloc) {

				return create_internal_t<type__>(alloc);
			}
			template<typename type__>
			static inline rtype_info_t* create_t() {

				allocator_type__ alloc;

				return create_internal_t<type__>(alloc);
			}

			inline void release() {

				allocator_type a = this->allocator;

				this->~rtype_info_t();

				a.deallocate(this, 0);
			}

		};

	}

}