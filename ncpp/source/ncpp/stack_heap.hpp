#pragma once

/** @file ncpp/stack_heap.hpp
 * 	@brief Implements stack heap.
*/



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Includes

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/prerequisites.hpp>

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/utilities/lref.hpp>
#include <ncpp/mem.hpp>

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/native_heap.hpp>
#include <ncpp/native_allocator.hpp>

#pragma endregion



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {

	struct stack_group;
	struct stack_chunk;
	struct stack_chunk_list;
	struct stack;
	struct in_stack_list;
	struct out_stack_list;
	struct stack_allocation;
	struct stack_allocation_list;



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct NCPP_DEFAULT_ALIGNAS stack_allocation {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct stack_group;
		friend struct stack_chunk;
		friend struct stack_chunk_list;
		friend struct stack;
		friend struct in_stack_list;
		friend struct out_stack_list;
		friend struct stack_allocation;
		friend struct stack_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		sz size_;
		stack* stack_p_;

		stack_allocation* prev_p_ = 0;
		stack_allocation* next_p_ = 0;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline sz size() const { return size_; }
		inline u8* data_p() const { return (u8*)(this + 1); }
		inline stack& stack() { return *stack_p_; }
		inline stack_allocation& prev() { return *prev_p_; }
		inline stack_allocation& next() { return *next_p_; }

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack_allocation(sz size, ncpp::stack& stack) :
			size_(size),
			stack_p_(&stack),

			prev_p_(0),
			next_p_(0)
		{



		}
		~stack_allocation() {



		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct stack_allocation_list {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct stack_group;
		friend struct stack_chunk;
		friend struct stack_chunk_list;
		friend struct stack;
		friend struct in_stack_list;
		friend struct out_stack_list;
		friend struct stack_allocation;
		friend struct stack_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		stack_allocation* head_p_;
		stack_allocation* tail_p_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack_allocation& head() { return *head_p_; }
		inline stack_allocation& tail() { return *tail_p_; }

		inline b8 is_empty() const { return head_p_ == 0; }

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack_allocation_list() :
			head_p_(0),
			tail_p_(0)
		{



		}
		inline stack_allocation_list(stack_allocation& head, stack_allocation& tail) :
			head_p_(&head),
			tail_p_(&tail)
		{



		}
		~stack_allocation_list() {



		}

		stack_allocation_list(const stack_allocation_list&) = delete;
		stack_allocation_list& operator = (const stack_allocation_list&) = delete;

		inline stack_allocation_list(stack_allocation_list&& other) :
			head_p_(other.head_p_),
			tail_p_(other.tail_p_)
		{

			other.head_p_ = 0;
			other.tail_p_ = 0;

		}
		inline stack_allocation_list& operator = (stack_allocation_list&& other)
		{

			head_p_ = other.head_p_;
			tail_p_ = other.tail_p_;

			other.head_p_ = 0;
			other.tail_p_ = 0;

			return *this;
		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline void insert(stack_allocation& s) {

			if (head_p_ == 0) {

				head_p_ = &s;
				tail_p_ = &s;

			}
			else {

				tail_p_->next_p_ = &s;
				s.prev_p_ = tail_p_;
				tail_p_ = &s;

			}

		}
		inline void erase(stack_allocation& s) {

			if (s.prev_p_ != 0) {

				s.prev_p_->next_p_ = s.next_p_;

			}
			else {

				head_p_ = s.next_p_;

			}
			if (s.next_p_ != 0) {

				s.next_p_->prev_p_ = s.prev_p_;

			}
			else {

				tail_p_ = s.prev_p_;

			}

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct stack {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct stack_group;
		friend struct stack_chunk;
		friend struct stack_chunk_list;
		friend struct stack;
		friend struct in_stack_list;
		friend struct out_stack_list;
		friend struct stack_allocation;
		friend struct stack_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		sz capacity_;
		sz usage_;
		u8* data_p_;
		stack_chunk* chunk_p_;

		stack* out_prev_p_ = 0;
		stack* out_next_p_ = 0;
		stack* in_prev_p_ = 0;
		stack* in_next_p_ = 0;

		stack_allocation_list allocation_list_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline sz capacity() const { return capacity_; }
		inline sz usage() const { return usage_; }
		inline u8* data_p() const { return data_p_; }
		inline stack_chunk& chunk() { return *chunk_p_; }
		inline stack& out_prev() { return *out_prev_p_; }
		inline stack& out_next() { return *out_next_p_; }
		inline stack& in_prev() { return *in_prev_p_; }
		inline stack& in_next() { return *in_next_p_; }

		inline stack_allocation_list& allocation_list() { return allocation_list_; }

		inline b8 is_empty() const { return usage_ == 0; }

		inline u8* pushable_pointer() {

			if (!allocation_list_.is_empty()) {

				auto& tail_allocation = allocation_list_.tail();

				return tail_allocation.data_p() + tail_allocation.size_;

			}

			return data_p_;
		}

		b8 is_pushable(sz size, sz align = NCPP_DEFAULT_ALIGN);

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack(sz capacity, stack_chunk& chunk) :
			capacity_(capacity),
			usage_(0),
			data_p_((u8*)(this + 1)),
			chunk_p_(&chunk),

			out_prev_p_(0),
			out_next_p_(0),
			in_prev_p_(0),
			in_next_p_(0)
		{



		}
		~stack() {



		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		/**
		 *	Returns aligned address shifting by the given address and align.
		 */
		inline uintptr_t align_address(uintptr_t addr, sz align)
		{
			const sz mask = align - 1;
			assert((align & mask) == 0 && "align value must be power of 2");
			return (addr + mask) & ~mask;
		}
		/**
		 *	Returns aligned pointer shifting by the given pointer and align.
		 */
		template<typename data_type>
		inline data_type* align_pointer(data_type* ptr, sz align)
		{
			const uintptr_t addr = reinterpret_cast<uintptr_t>(ptr);
			return reinterpret_cast<data_type*>(align_address(addr, align));
		}
		/**
		 *	Aligned allocates a memory block by given size and align.
		 */
		inline u8* aligned_alloc(sz size, sz align)
		{

			sz actual_size = size + sizeof(stack_allocation) + align;

			u8* raw_ptr = pushable_pointer();
			usage_ += size + align + sizeof(sz);

			u8* aligned_ptr = align_pointer(raw_ptr, align);

			if (aligned_ptr == raw_ptr)
				aligned_ptr += align;

			stack_allocation* allocation_p = reinterpret_cast<stack_allocation*>(aligned_ptr);
			new(allocation_p) stack_allocation(actual_size, *this);

			allocation_list_.insert(*allocation_p);

			return reinterpret_cast<u8*>(allocation_p + 1);
		}



	public:
		inline u8* allocate(sz size, sz align = NCPP_DEFAULT_ALIGN) {

			return aligned_alloc(size, align);
		}
		inline void deallocate(stack_allocation* allocation_p) {

			allocation_list_.erase(*allocation_p);

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct in_stack_list {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct stack_group;
		friend struct stack_chunk;
		friend struct stack_chunk_list;
		friend struct stack;
		friend struct in_stack_list;
		friend struct out_stack_list;
		friend struct stack_allocation;
		friend struct stack_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		stack* head_p_;
		stack* tail_p_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack& head() { return *head_p_; }
		inline stack& tail() { return *tail_p_; }

		inline b8 is_empty() const { return head_p_ == 0; }

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline in_stack_list() :
			head_p_(0),
			tail_p_(0)
		{



		}
		inline in_stack_list(stack& head, stack& tail) :
			head_p_(&head),
			tail_p_(&tail)
		{



		}
		~in_stack_list() {



		}

		in_stack_list(const in_stack_list&) = delete;
		in_stack_list& operator = (const in_stack_list&) = delete;

		inline in_stack_list(in_stack_list&& other) :
			head_p_(other.head_p_),
			tail_p_(other.tail_p_)
		{

			other.head_p_ = 0;
			other.tail_p_ = 0;

		}
		inline in_stack_list& operator = (in_stack_list&& other)
		{

			head_p_ = other.head_p_;
			tail_p_ = other.tail_p_;

			other.head_p_ = 0;
			other.tail_p_ = 0;

			return *this;
		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline void insert(stack& s) {

			if (head_p_ == 0) {

				head_p_ = &s;
				tail_p_ = &s;

			}
			else {

				tail_p_->in_next_p_ = &s;
				s.in_prev_p_ = tail_p_;
				tail_p_ = &s;

			}

		}
		inline void erase(stack& s) {

			if (s.in_prev_p_ != 0) {

				s.in_prev_p_->in_next_p_ = s.in_next_p_;

			}
			else {

				head_p_ = s.in_next_p_;

			}
			if (s.in_next_p_ != 0) {

				s.in_next_p_->in_prev_p_ = s.in_prev_p_;

			}
			else {

				tail_p_ = s.in_prev_p_;

			}

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct out_stack_list {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct stack_group;
		friend struct stack_chunk;
		friend struct stack_chunk_list;
		friend struct stack;
		friend struct in_stack_list;
		friend struct out_stack_list;
		friend struct stack_allocation;
		friend struct stack_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		stack* head_p_;
		stack* tail_p_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack& head() { return *head_p_; }
		inline stack& tail() { return *tail_p_; }

		inline b8 is_empty() const { return head_p_ == 0; }

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline out_stack_list() :
			head_p_(0),
			tail_p_(0)
		{



		}
		inline out_stack_list(stack& head, stack& tail) :
			head_p_(&head),
			tail_p_(&tail)
		{



		}
		~out_stack_list() {



		}

		out_stack_list(const out_stack_list&) = delete;
		out_stack_list& operator = (const out_stack_list&) = delete;

		inline out_stack_list(out_stack_list&& other) :
			head_p_(other.head_p_),
			tail_p_(other.tail_p_)
		{

			other.head_p_ = 0;
			other.tail_p_ = 0;

		}
		inline out_stack_list& operator = (out_stack_list&& other)
		{

			head_p_ = other.head_p_;
			tail_p_ = other.tail_p_;

			other.head_p_ = 0;
			other.tail_p_ = 0;

			return *this;
		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline void insert(stack& s) {

			if (head_p_ == 0) {

				head_p_ = &s;
				tail_p_ = &s;

			}
			else {

				tail_p_->out_next_p_ = &s;
				s.out_prev_p_ = tail_p_;
				tail_p_ = &s;

			}

		}
		inline void erase(stack& s) {

			if (s.out_prev_p_ != 0) {

				s.out_prev_p_->out_next_p_ = s.out_next_p_;

			}
			else {

				head_p_ = s.out_next_p_;

			}
			if (s.out_next_p_ != 0) {

				s.out_next_p_->out_prev_p_ = s.out_prev_p_;

			}
			else {

				tail_p_ = s.out_prev_p_;

			}

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct stack_chunk {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct stack_group;
		friend struct stack_chunk;
		friend struct stack_chunk_list;
		friend struct stack;
		friend struct in_stack_list;
		friend struct out_stack_list;
		friend struct stack_allocation;
		friend struct stack_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		sz stack_capacity_;
		sz stack_count_;
		sz initialized_stack_count_;
		u8* data_p_;

		in_stack_list free_list_;
		in_stack_list available_list_;
			
		stack_chunk* prev_p_ = 0;
		stack_chunk* next_p_ = 0;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline sz stack_capacity() const { return stack_capacity_; }
		inline sz stack_count() const { return stack_count_; }
		inline sz initialized_stack_count() const { return initialized_stack_count_; }
		inline u8* data_p() const { return data_p_; }

		inline in_stack_list& free_list() { return free_list_; }
		inline in_stack_list& available_list() { return available_list_; }

		inline stack_chunk& prev() { return *prev_p_; }
		inline stack_chunk& next() { return *next_p_; }

		inline b8 is_empty() const { return available_list_.is_empty(); }

		b8 is_pushable(sz size, sz align = NCPP_DEFAULT_ALIGN);

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack_chunk(sz stack_capacity, sz stack_count) :
			stack_capacity_(stack_capacity),
			stack_count_(stack_count),
			data_p_((u8*)(this + 1)),

			initialized_stack_count_(0)
		{



		}
		~stack_chunk() {



		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack& pick_a_stack(sz size, sz align = NCPP_DEFAULT_ALIGN) {



			utilities::lref_t<stack> stack_ref;



			if (initialized_stack_count_ < stack_count_) {

				sz stack_size = sizeof(stack) + stack_capacity_;

				stack_ref = *((stack*)(data_p_ + stack_size * initialized_stack_count_));
				new(stack_ref.pointer()) stack(stack_capacity_, *this);

			}
			else {

				stack_ref = free_list_.tail();
				free_list_.erase(*stack_ref);

			}



			available_list_.insert(*stack_ref);



			return *stack_ref;
		}

		inline void erase_stack(stack& s) {

			available_list_.erase(s);
			free_list_.insert(s);

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct stack_chunk_list {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct stack_group;
		friend struct stack_chunk;
		friend struct stack_chunk_list;
		friend struct stack;
		friend struct in_stack_list;
		friend struct out_stack_list;
		friend struct stack_allocation;
		friend struct stack_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		stack_chunk* head_p_;
		stack_chunk* tail_p_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack_chunk& head() { return *head_p_; }
		inline stack_chunk& tail() { return *tail_p_; }

		inline b8 is_empty() const { return head_p_ == 0; }

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack_chunk_list() :
			head_p_(0),
			tail_p_(0)
		{



		}
		inline stack_chunk_list(stack_chunk& head, stack_chunk& tail) :
			head_p_(&head),
			tail_p_(&tail)
		{



		}
		~stack_chunk_list() {



		}

		stack_chunk_list(const stack_chunk_list&) = delete;
		stack_chunk_list& operator = (const stack_chunk_list&) = delete;

		inline stack_chunk_list(stack_chunk_list&& other) :
			head_p_(other.head_p_),
			tail_p_(other.tail_p_)
		{

			other.head_p_ = 0;
			other.tail_p_ = 0;

		}
		inline stack_chunk_list& operator = (stack_chunk_list&& other)
		{

			head_p_ = other.head_p_;
			tail_p_ = other.tail_p_;

			other.head_p_ = 0;
			other.tail_p_ = 0;

			return *this;
		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline void insert(stack_chunk& s) {

			if (head_p_ == 0) {

				head_p_ = &s;
				tail_p_ = &s;

			}
			else {

				tail_p_->next_p_ = &s;
				s.prev_p_ = tail_p_;
				tail_p_ = &s;

			}

		}
		inline void erase(stack_chunk& s) {

			if (s.prev_p_ != 0) {

				s.prev_p_->next_p_ = s.next_p_;

			}
			else {

				head_p_ = s.next_p_;

			}
			if (s.next_p_ != 0) {

				s.next_p_->prev_p_ = s.prev_p_;

			}
			else {

				tail_p_ = s.prev_p_;

			}

		}

		inline void reset() {

			head_p_ = 0;
			tail_p_ = 0;

		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	struct stack_group {

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct stack_group;
		friend struct stack_chunk;
		friend struct stack_chunk_list;
		friend struct stack;
		friend struct in_stack_list;
		friend struct out_stack_list;
		friend struct stack_allocation;
		friend struct stack_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	private:
		out_stack_list out_stack_list_;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline out_stack_list& out_stack_list() { return out_stack_list_; }

		inline b8 is_empty() const { return out_stack_list_.is_empty(); }

		b8 is_pushable(sz size, sz align = NCPP_DEFAULT_ALIGN);

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		inline stack_group()
		{



		}
		~stack_group() {



		}

	};



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	template<
		class allocator_type__ = typename NCPP_DEFAULT_ALLOCATOR_TEMPLATE<u8>
	>
	class stack_heap_t :
		public native_heap
	{

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

	public:
		friend struct stack_group;
		friend struct stack_chunk;
		friend struct stack_chunk_list;
		friend struct stack;
		friend struct in_stack_list;
		friend struct out_stack_list;
		friend struct stack_allocation;
		friend struct stack_allocation_list;

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Typedefs
	public:
		using allocator_type = allocator_type__;
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Properties
	private:
		sz stack_capacity_;
		sz stack_count_per_chunk_;

		stack_chunk_list available_chunk_list_;
		stack_chunk_list empty_chunk_list_;

		allocator_type__ allocator_;
#pragma endregion 

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Getters
	public:
		inline sz stack_capacity() const { return stack_capacity_; }
		inline sz stack_count_per_chunk() const { return stack_count_per_chunk_; }

		inline stack_chunk_list& available_chunk_list() { return available_chunk_list_; }
		inline stack_chunk_list& empty_chunk_list() { return empty_chunk_list_; }

		inline allocator_type__& allocator() { return allocator_; }
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Constructors, Destructor and Operators
	public:
		inline stack_heap_t(
			sz stack_capacity = NCPP_DEFAULT_STACK_CAPACITY,
			sz stack_count_per_chunk = NCPP_DEFAULT_STACK_COUNT_PER_CHUNK
		) :
			stack_capacity_(stack_capacity),
			stack_count_per_chunk_(stack_count_per_chunk)
		{



		}
		~stack_heap_t() {

			clear();

		}

		inline stack_heap_t(const stack_heap_t&) = delete;
		inline stack_heap_t& operator = (const stack_heap_t&) = delete;
		inline stack_heap_t(stack_heap_t&&) = delete;
		inline stack_heap_t& operator = (stack_heap_t&&) = delete;
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Public Methods
	private:
		inline stack_chunk& push_chunk() {

			utilities::lref_t<stack_chunk> chunk_ref;



			sz stack_size = stack_capacity_ + sizeof(stack);
			sz allocation_size = sizeof(stack_chunk) + stack_size * stack_count_per_chunk_;

			stack_chunk* chunk_p = (stack_chunk*)allocator_.allocate(allocation_size);
			new(chunk_p) stack_chunk(stack_capacity_, stack_count_per_chunk_);

			chunk_ref = *chunk_p;



			empty_chunk_list_.insert(*chunk_ref);



			return *chunk_ref;
		}
		inline void release_chunk(stack_chunk& chunk) {

			sz stack_size = stack_capacity_ + sizeof(stack);
			sz allocation_size = sizeof(stack_chunk) + stack_size * stack_count_per_chunk_;

			allocator_.deallocate((u8*)&chunk, allocation_size);
		}

		inline stack& pick_a_stack(sz size, sz align = NCPP_DEFAULT_ALIGN) {



			utilities::lref_t<stack> stack_ref;

			utilities::lref_t<stack_chunk> chunk_ref;



			/// pick a chunk
			if (available_chunk_list_.is_empty()) {

				chunk_ref = push_chunk();

				empty_chunk_list_.erase(*chunk_ref);

				available_chunk_list_.insert(*chunk_ref);

			}
			else {

				if (available_chunk_list_.tail().is_pushable(size, align)) {

					chunk_ref = available_chunk_list_.tail();

				}
				else {

					chunk_ref = push_chunk();

					empty_chunk_list_.erase(*chunk_ref);

					available_chunk_list_.insert(*chunk_ref);

				}
								
			}



			/// pick a stack from the chunk
			stack_ref = chunk_ref->pick_a_stack(size, align);



			return *stack_ref;
		}



	public:
		inline u8* allocate(stack_group& group, sz size, sz align = NCPP_DEFAULT_ALIGN) {

			assert(size + sizeof(stack_allocation) + align <= stack_capacity_ && "allocation size is too large to be allocated in this stack heap.");



			if (group.is_pushable(size, align)) {

				stack& s = group.out_stack_list().tail();

				return s.allocate(size, align);

			}
			else {

				stack& s = pick_a_stack(size, align);

				group.out_stack_list().insert(s);

				return s.allocate(size, align);

			}



			return 0;
		}
		inline void deallocate(stack_group& group, void* ptr) {

			stack_allocation* allocation_p = reinterpret_cast<stack_allocation*>(ptr) - 1;

			stack& s = allocation_p->stack();
			stack_chunk& chunk = s.chunk();

			s.deallocate(allocation_p);

			if (s.is_empty()) {

				chunk.erase_stack(s);
				group.out_stack_list().erase(s);

			}

			if (chunk.is_empty()) {

				if (empty_chunk_list_.is_empty()) {

					available_chunk_list_.erase(chunk);
					empty_chunk_list_.insert(chunk);

				}
				else {

					available_chunk_list_.erase(chunk);

					release_chunk(chunk);

				}

			}

		}

		inline void clear() {

			stack_chunk* chunk_p = &(empty_chunk_list_.head());
			while (chunk_p != 0) {

				stack_chunk* next_chunk_p = &(chunk_p->next());

				release_chunk(*chunk_p);

				chunk_p = next_chunk_p;

			}
			empty_chunk_list_.reset();

			chunk_p = &(available_chunk_list_.head());
			while (chunk_p != 0) {

				stack_chunk* next_chunk_p = &(chunk_p->next());

				release_chunk(*chunk_p);

				chunk_p = next_chunk_p;

			}
			empty_chunk_list_.reset();
		}
#pragma endregion

	};

}

