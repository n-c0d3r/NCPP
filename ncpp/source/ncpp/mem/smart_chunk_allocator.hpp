#pragma once

/** @file ncpp/chunk_allocator.hpp
*	@brief Implements chunk allocator.
*/



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Includes

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/prerequisites.hpp>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/containers/ring_buffer.hpp>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/mem/allocator.hpp>
#include <ncpp/mem/default_allocator.hpp>

#pragma endregion



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {

	namespace mem {

		struct NCPP_ALIGN(EASTL_ALLOCATOR_MIN_ALIGNMENT) F_smart_chunk_header {

			sz usage = 0;
			F_smart_chunk_header* pev_p = 0;
			F_smart_chunk_header* next_p = 0;

			inline u8* data_root() {

				return reinterpret_cast<u8*>(this + 1);
			}

			inline u8* current_data() {

				return data_root() + usage;
			}

		};



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



		struct F_default_smart_chunk_options {

			using F_chunk_p_ring_buffer = containers::TF_ring_buffer<F_smart_chunk_header, F_default_allocator>;

		};



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



		template<class F_options__ = F_default_smart_chunk_options>
		class TF_smart_chunk_storage;
		template<class F_options__ = F_default_smart_chunk_options>
		class TF_smart_chunk_adaptor;
		template<class F_options__ = F_default_smart_chunk_options>
		class TF_smart_chunk_allocator;



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#define NCPP_SMART_CHUNK_STORAGE_DEFAULT_CHUNK_COUNT 512
#define NCPP_SMART_CHUNK_ADAPTOR_DEFAULT_MAX_CHUNK_COUNT 16

		// Default smart chunk capacity, 256KiB
#define NCPP_DEFAULT_SMART_CHUNK_CAPACITY 256141



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



		template<class F_options__>
		class TF_smart_chunk_storage {

		public:
			using F_options = F_options__;
			using F_storage = TF_smart_chunk_storage<F_options>;
			using F_adaptor = TF_smart_chunk_adaptor<F_options>;
			using F_allocator = TF_smart_chunk_allocator<F_options>;



		private:
			sz chunk_count_ = 0;
			sz chunk_capacity_ = 0;

		public:
			inline sz chunk_count() const { return chunk_count_; }
			inline sz chunk_capacity() const { return chunk_capacity_; }



		public:
			inline TF_smart_chunk_storage(sz chunk_count = NCPP_SMART_CHUNK_STORAGE_DEFAULT_CHUNK_COUNT, sz chunk_capacity = NCPP_DEFAULT_SMART_CHUNK_CAPACITY) :
				chunk_count_(chunk_count),
				chunk_capacity_(chunk_capacity)
			{

				init_chunks_internal();

			}
			~TF_smart_chunk_storage() {

				reset();

			}



		private:
			void init_chunks_internal() {



			}



		public:
			void reset() {



			}

			void push_chunk(F_smart_chunk_header* chunk_p) {



			}
			F_smart_chunk_header* pop_chunk() {

				return 0;
			}

		};



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




		template<class F_options__>
		class TF_smart_chunk_adaptor {

		public:
			using F_options = F_options__;
			using F_storage = TF_smart_chunk_storage<F_options>;
			using F_adaptor = TF_smart_chunk_adaptor<F_options>;
			using F_allocator = TF_smart_chunk_allocator<F_options>;



		private:
			F_storage* storage_p_ = 0;

			sz max_chunk_count_ = 0;
			sz chunk_capacity_ = 0;

		public:
			inline F_storage* storage_p() { return storage_p_; }

			inline sz max_chunk_count() const { return max_chunk_count_; }
			inline sz chunk_capacity() const { return chunk_capacity_; }



		public:
			inline TF_smart_chunk_adaptor(F_storage* storage_p, sz max_chunk_count = NCPP_SMART_CHUNK_ADAPTOR_DEFAULT_MAX_CHUNK_COUNT) :
				storage_p_(storage_p),

				max_chunk_count_(max_chunk_count)
			{

				if (storage_p_)
					chunk_capacity_ = storage_p->chunk_capacity();

			}
			~TF_smart_chunk_adaptor() {

				reset();

			}



		public:
			void reset() {



			}

			void push_chunk(F_smart_chunk_header* chunk_p) {



			}
			F_smart_chunk_header* pop_chunk() {

				return 0;
			}

		};



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



		/**
		 * An allocator is similar to F_incremental_chunk_allocator but is capable of releasing empty chunks.
		 * It maintains a count of used memory and returns a pointer to the chunk plus the
		 * memory count each time memory is allocated.
		 *
		 * When deallocating memory, this allocator follows a smart approach:
		 * - If the chunk of the allocation is not the latest chunk and
		 * - The memory usage in that chunk after deallocation of this allocation is zero,
		 * Then it deallocates that chunk.
		 */
		template<class F_options__>
		class TF_smart_chunk_allocator : public TI_allocator<TF_smart_chunk_allocator<F_options__>> {

		private:
			using F_base = TI_allocator<TF_smart_chunk_allocator<F_options__>>;



		public:
			using F_options = F_options__;
			using F_storage = TF_smart_chunk_storage<F_options>;
			using F_adaptor = TF_smart_chunk_adaptor<F_options>;
			using F_allocator = TF_smart_chunk_allocator<F_options>;



		private:
			F_adaptor* adaptor_p_ = 0;

			F_smart_chunk_header* head_chunk_p_ = 0;
			F_smart_chunk_header* tail_chunk_p_ = 0;
			u16 chunk_count_ = 0;

			F_smart_chunk_header* current_chunk_p_ = 0;
			sz current_usage_ = 0;

			sz chunk_capacity_;
			u16 min_chunk_count_;

#ifdef NCPP_ENABLE_MEMORY_COUNTING
			sz usable_allocated_memory_ = 0;
#endif



		public:
			inline F_adaptor* adaptor_p() { return adaptor_p_; }

			inline sz chunk_capacity() const { return chunk_capacity_; }
			inline u16 min_chunk_count() const { return min_chunk_count_; }
			inline u16 chunk_count() const { return chunk_count_; }



		public:
			// Default chunk capacity is 2MiB
			inline TF_smart_chunk_allocator(F_adaptor* adaptor_p, u16 min_chunk_count = 0, const char* name = 0) :
				F_base(name),
				adaptor_p_(adaptor_p),

				chunk_capacity_(0),
				min_chunk_count_(min_chunk_count),
				current_usage_(0)
			{

				if (adaptor_p_) {

					chunk_capacity_ = adaptor_p_->chunk_capacity();
					current_usage_ = chunk_capacity_;
				}

				validate_chunk_count();

			}
			inline TF_smart_chunk_allocator(const TF_smart_chunk_allocator& x) :
				TF_smart_chunk_allocator(x.adaptor_p_, x.min_chunk_count_, x.name_)
			{



			}

			~TF_smart_chunk_allocator() {

				reset();
			}



		private:
			inline F_smart_chunk_header* push_new_chunk() {

				assert(adaptor_p_ && "adaptor is null, cant push new chunk");

				F_smart_chunk_header* new_chunk_p = adaptor_p_->pop_chunk();

				*new_chunk_p = {
				
					0,
					tail_chunk_p_

				};

				if (tail_chunk_p_)
					tail_chunk_p_->next_p = new_chunk_p;
				else
					head_chunk_p_ = new_chunk_p;

				tail_chunk_p_ = new_chunk_p;

				++chunk_count_;

				return new_chunk_p;
			}
			inline F_smart_chunk_header* optain_next_chunk(F_smart_chunk_header* chunk_p) {

				if (chunk_p && chunk_p->next_p) {

					chunk_p->next_p->usage = 0;

					return chunk_p->next_p;
				}

				return push_new_chunk();
			}
			inline void erase_chunk(F_smart_chunk_header* chunk_p) {

				assert(adaptor_p_ && "adaptor is null, cant erase chunk");

				F_smart_chunk_header* prev_chunk_p = chunk_p->pev_p;
				F_smart_chunk_header* next_chunk_p = chunk_p->next_p;

				if (prev_chunk_p) {

					prev_chunk_p->next_p = next_chunk_p;
				}
				else
					head_chunk_p_ = next_chunk_p;
				if (next_chunk_p) {

					next_chunk_p->pev_p = prev_chunk_p;
				}
				else
					tail_chunk_p_ = prev_chunk_p;

				adaptor_p_->push_chunk(chunk_p);

				--chunk_count_;

			}

		public:
			inline void* new_mem(sz size) {

				assert((size <= chunk_capacity_) && "allocation size too big");
				assert(adaptor_p_ && "adaptor is null, cant allocate memory");

				current_usage_ += size;



#ifdef NCPP_ENABLE_MEMORY_COUNTING
				NCPP_INCREASE_USABLE_ALLOCATED_MEMORY(size);
				usable_allocated_memory_ += size;
#endif



				if (current_usage_ > chunk_capacity_)
				{

					current_chunk_p_ = optain_next_chunk(current_chunk_p_);

					current_usage_ = size;

				}



				void* memory_p = current_chunk_p_->current_data();



				current_chunk_p_->usage = current_usage_;



				return memory_p;

			}
			inline void delete_mem(void* p) {

				assert(adaptor_p_ && "adaptor is null, cant deallocate memory");

				/*
				F_smart_chunk_allocation_header* allocation_header_p = reinterpret_cast<F_smart_chunk_allocation_header*>(p) - 1;

				F_smart_chunk_header* chunk_p = allocation_header_p->chunk_p;



#ifdef NCPP_ENABLE_MEMORY_COUNTING
				NCPP_DECREASE_USABLE_ALLOCATED_MEMORY(allocation_header_p->actual_size - sizeof(F_smart_chunk_allocation_header));
				usable_allocated_memory_ -= allocation_header_p->actual_size - sizeof(F_smart_chunk_allocation_header);
#endif



				if ((allocation_header_p->actual_size == chunk_p->usage) && (chunk_p != current_chunk_p_)) {

					erase_chunk(chunk_p);

				}
				else
					chunk_p->usage -= allocation_header_p->actual_size;
*/
			}

			/**
			 *	Deallocates all chunks.
			 */
			void reset() {

				if (!adaptor_p_)
					return;

#ifdef NCPP_ENABLE_MEMORY_COUNTING
				NCPP_DECREASE_USABLE_ALLOCATED_MEMORY(usable_allocated_memory_);
				usable_allocated_memory_ = 0;
#endif

				while (chunk_count_) {

					erase_chunk(tail_chunk_p_);

				}

				current_usage_ = chunk_capacity_;

			}
			/**
			 *	Resets memory usage, sets the first chunk as current chunk and also deallocates chunks until there is only min_chunk_count_ chunks.
			 */
			void clear() {

				if (!adaptor_p_)
					return;

#ifdef NCPP_ENABLE_MEMORY_COUNTING
				NCPP_DECREASE_USABLE_ALLOCATED_MEMORY(usable_allocated_memory_);
				usable_allocated_memory_ = 0;
#endif

				if (chunk_count_ == 0)
					return;

				while (chunk_count_ > min_chunk_count_) {

					erase_chunk(tail_chunk_p_);

				}

				current_chunk_p_ = tail_chunk_p_;

				while (current_chunk_p_ != head_chunk_p_) {

					current_chunk_p_->usage = 0;

					current_chunk_p_ = current_chunk_p_->pev_p;

				}

				if (!current_chunk_p_)
					current_usage_ = chunk_capacity_;

			}

			void validate_chunk_count() {

				if (!adaptor_p_)
					return;

				while (chunk_count_ < min_chunk_count_) {

					current_chunk_p_ = optain_next_chunk(current_chunk_p_);

				}

				clear();

			}

		};

	}

}

