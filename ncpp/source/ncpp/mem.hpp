#pragma once

/** @file ncpp/mem.hpp
*	@brief Contains the memory management utilities.
*/



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Includes

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/prerequisites.hpp>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef NCPP_ENABLE_NATIVE_MEMORY_COUNTING
#include <ncpp/native_memory_counting.hpp>
#endif

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/native_allocator.hpp>

#pragma endregion



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	void log_memory_stats();



#pragma region Implements aligned allocation,...
	/**
	 *	Returns aligned address shifting from the given address and align.
	 */
	inline uintptr_t align_address(uintptr_t addr, sz align)
	{
		const sz mask = align - 1;
		assert((align & mask) == 0 && "align value must be power of 2");
		return (addr + mask) & ~mask;
	}
	/**
	 *	Returns aligned pointer shifting from the given pointer and align.
	 */
	template<typename data_type>
	inline data_type* align_pointer(data_type* ptr, sz align)
	{
		const uintptr_t addr = reinterpret_cast<uintptr_t>(ptr);
		return reinterpret_cast<data_type*>(align_address(addr, align));
	}
	/**
	 *	Aligned allocates a memory block from given size and align.
	 */
	inline void* aligned_alloc(sz size, sz align)
	{

		sz additional_size = sizeof(sz) + sizeof(native_allocator_i**);

		sz actual_size = additional_size + size + align;

		u8* raw_ptr = new u8[actual_size];



		u8* additionized_ptr = raw_ptr + additional_size;



		u8* aligned_ptr = align_pointer(additionized_ptr, align);

		if (aligned_ptr == additionized_ptr)
			aligned_ptr += align;

		ptrdiff_t shift = aligned_ptr - additionized_ptr;
		assert(shift > 0 && shift <= 256);



		native_allocator_i** allocator_pp = reinterpret_cast<native_allocator_i**>(aligned_ptr) - 1;
		*allocator_pp = &current_native_allocator();

		*(reinterpret_cast<sz*>(allocator_pp) - 1) = actual_size;
		*(reinterpret_cast<u8*>(allocator_pp) - sizeof(sz) - 1) = static_cast<u8>(shift & 0xFF);



#ifdef NCPP_ENABLE_NATIVE_MEMORY_COUNTING
		increase_native_allocated_memory(actual_size);
#endif
				
		return aligned_ptr;
	}

	/**
	 *	Gets actual size from aligned pointer
	 */
	inline sz actual_size_aligned(void* ptr)
	{

		native_allocator_i** allocator_pp = reinterpret_cast<native_allocator_i**>(ptr) - 1;
		*allocator_pp = &current_native_allocator();

		return *(reinterpret_cast<sz*>(allocator_pp) - 1);
	}

	/**
	 *	Aligned frees a memory block.
	 */
	inline void aligned_free(void* ptr)
	{

		u8* aligned_ptr = reinterpret_cast<u8*>(ptr);

		native_allocator_i** allocator_pp = reinterpret_cast<native_allocator_i**>(aligned_ptr) - 1;

		sz actual_size = *(reinterpret_cast<sz*>(allocator_pp) - 1);

		ptrdiff_t shift = *(reinterpret_cast<u8*>(allocator_pp) - sizeof(sz) - 1);
		if (shift == 0)
			shift = 256;



		u8* raw_ptr = (reinterpret_cast<u8*>(allocator_pp) - sizeof(sz)) - shift;



#ifdef NCPP_ENABLE_NATIVE_MEMORY_COUNTING
		decrease_native_allocated_memory(actual_size);
#endif



		delete[] raw_ptr;

	}
#pragma endregion



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Allocators
	template <class value_type__>
	class aligned_allocator_t :
		public native_allocator_t<value_type__>
	{

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	public:
		using size_type = sz;
		using difference_type = ptrdiff_t;
		using pointer = value_type__*;
		using const_pointer = const value_type__*;
		using reference = value_type__&;
		using const_reference = const value_type__&;
		using value_type = value_type__;

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	public:
		inline aligned_allocator_t()
		{



		}

		inline aligned_allocator_t<value_type>& operator=(const aligned_allocator_t& other) {



			return *this;
		}

		template <class other_value_type__>
		inline aligned_allocator_t(const aligned_allocator_t<other_value_type__>& other) {



		}

		template <class other_value_type__>
		inline aligned_allocator_t& operator=(const aligned_allocator_t<other_value_type__>& other) {



			return *this;
		}

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	private:
		inline pointer internal_allocate(size_type n, sz align = 1) const {

			return (pointer)aligned_alloc(n * sizeof(value_type), align);
		}
		inline void internal_deallocate(pointer ptr, sz n = 1) const {

			aligned_free(ptr);
		}

	protected:
		void* abstract_allocate(size_type size, sz align = 1) {

			return (void*)internal_allocate(size / sizeof(value_type__), align);
		}
		void abstract_deallocate(void* ptr, sz size = sizeof(value_type__)) {

			internal_deallocate((pointer)ptr, size / sizeof(value_type__));
		}

	public:
		inline pointer   allocate(size_type n, sz align = 1) const {

			return internal_allocate(n, align);
		}

		inline void      deallocate(pointer ptr, sz n = 1) const {

			internal_deallocate(ptr, n);
		}

		inline pointer           address(reference x) const { return &x; }
		inline const_pointer     address(const_reference x) const { return &x; }
		inline void              construct(pointer p, const value_type& val)
		{
			new ((value_type*)p) value_type(val);
		}
		inline void              destroy(pointer p) { p->~value_type(); }

		inline size_type         max_size() const { return size_t(-1); }

		template <class U>
		struct rebind { typedef aligned_allocator_t<U> other; };
	};
#pragma endregion



	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Allocators
	template <class value_type__>
	class crt_allocator_t :
		public native_allocator_t<value_type__>
	{

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	public:
		using size_type = sz;
		using difference_type = ptrdiff_t;
		using pointer = value_type__*;
		using const_pointer = const value_type__*;
		using reference = value_type__&;
		using const_reference = const value_type__&;
		using value_type = value_type__;

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	public:
		inline crt_allocator_t()
		{



		}

		inline crt_allocator_t<value_type>& operator=(const crt_allocator_t& other) {



			return *this;
		}

		template <class other_value_type__>
		inline crt_allocator_t(const crt_allocator_t<other_value_type__>& other) {



		}

		template <class other_value_type__>
		inline crt_allocator_t& operator=(const crt_allocator_t<other_value_type__>& other) {



			return *this;
		}

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	private:
		inline pointer internal_allocate(size_type n, sz align = 1) const {

			size_type actual_size = n * sizeof(value_type);

			return (pointer)malloc(actual_size);
		}
		inline void internal_deallocate(pointer ptr, sz n = 1) const {

			free(ptr);
		}

	protected:
		void* abstract_allocate(size_type size, sz align = 1) const {

			return (void*)internal_allocate(size / sizeof(value_type__), align);
		}
		void abstract_deallocate(void* ptr, sz size = sizeof(value_type__)) const {

			internal_deallocate((pointer)ptr, size / sizeof(value_type__));
		}

	public:
		inline pointer   allocate(size_type n, sz align = 1) const {

			return internal_allocate(n, align);
		}

		inline void      deallocate(pointer ptr, sz n = 1) const {

			internal_deallocate(ptr, n);
		}

		inline pointer           address(reference x) const { return &x; }
		inline const_pointer     address(const_reference x) const { return &x; }
		inline void              construct(pointer p, const value_type& val)
		{
			new ((value_type*)p) value_type(val);
		}
		inline void              destroy(pointer p) { p->~value_type(); }

		inline size_type         max_size() const { return size_t(-1); }

		template <class U>
		struct rebind { typedef crt_allocator_t<U> other; };
	};
#pragma endregion

}

