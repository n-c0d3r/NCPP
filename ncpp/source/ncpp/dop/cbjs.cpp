#include <ncpp/.hpp>



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {

	namespace dop {



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Job

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Job Methods
		void job::execute(job_coroutine& coroutine) {

			std::atomic_thread_fence(std::memory_order_release);

			u32 index = ran_instance_count_.load(std::memory_order_relaxed);

			while (!ran_instance_count_.compare_exchange_weak(index, index + 1));



			entry_point_(index, coroutine);



			u32 done_instance_count = done_instance_count_.load(std::memory_order_relaxed);

			while (!done_instance_count_.compare_exchange_weak(done_instance_count, done_instance_count + 1));

			if (done_instance_count == instance_count_ - 1) {

				is_done_.store(true, std::memory_order_relaxed);

			}



			std::atomic_thread_fence(std::memory_order_acquire);

		}
#pragma endregion

#pragma endregion



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Job Coroutine

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Job Coroutine Methods
		void job_coroutine::worker_loop()
		{

			while (cbjs::instance().is_running()) {

				job_->execute(*this);

				caller_thread_fiber_->switch_to_this();

			}

		}

		void job_coroutine::delayed_init() {

			worker_thread_index_ = current_worker_thread().index();

			fiber_.delayed_init();
		}
#pragma endregion

#pragma endregion



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Job Coroutine Pool

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Job Coroutine Pool Constructors, Destructor and Operators
		job_coroutine_pool::job_coroutine_pool(sz count = NCPP_COROUTINE_COUNT_PER_WORKER_THREAD) :
			count_(count),

			coroutine_ref_allocator_(cbjs::instance().tagged_heap(), cbjs::instance().tgh_sys_lifetime_cid()),
			coroutine_allocator_(cbjs::instance().tagged_heap(), cbjs::instance().tgh_sys_lifetime_cid()),

			coroutine_ref_queue_(count, coroutine_ref_allocator_),
			coroutine_vector_(count, coroutine_allocator_)
		{

			coroutine_vector_.resize(count);

			for (sz i = 0; i < count; ++i) {

				coroutine_ref_queue_.push(coroutine_vector_[i]);

			}

		}
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Job Coroutine Pool Methods

#pragma endregion

#pragma endregion



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Worker Thread

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Worker Thread Constructors, Destructor and Operators
		worker_thread::worker_thread(u8 index, sz coroutine_count) :
			index_(index),
			unique_pac_thread_(),
			pac_thread_((index == 0) ? pac::main_thread() : unique_pac_thread_),
			coroutine_pool_(coroutine_count),

			coroutine_ref_allocator_(cbjs::instance().tagged_heap_, cbjs::instance().tgh_sys_lifetime_cid()),
			coroutine_ref_queue_HIGH_(coroutine_count, coroutine_ref_allocator_),
			coroutine_ref_queue_NORMAL_(coroutine_count, coroutine_ref_allocator_),
			coroutine_ref_queue_LOW_(coroutine_count, coroutine_ref_allocator_)
		{



		}
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Worker Thread TLS
		thread_local utilities::a_lref_t<worker_thread> current_worker_thread_g;

		worker_thread& current_worker_thread() {

			return *current_worker_thread_g;
		}
#pragma endregion

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region Worker Thread Methods
		void worker_thread::worker_loop() {

			current_worker_thread_g = *this;



			coroutine_pool_.delayed_init();



			cbjs::instance().not_initialized_wthread_count_.fetch_sub(1);



			while (!cbjs::instance().is_initialized_done());



			if (index_ == 0) {

				cbjs::instance().schedule(cbjs::instance().settings_.entry_job);

			}



			while (cbjs::instance().is_running()) {

				if (index_ == 0) {

					if (cbjs::instance().settings_.entry_job->is_done())
						cbjs::instance().is_running_ = false;

				}



				for (u32 i = 0; i < NCPP_DOP_JOB_HIGH_STEP; ++i) {

					utilities::a_lref_t<job_coroutine> coroutine;



					if (pick_or_steal_coroutine_HIGH(coroutine)) {

						job& job = coroutine->job();



						if (coroutine->is_waiting()) {

							coroutine_ref_queue_HIGH_.push(coroutine);

						}
						else {

							coroutine->caller_thread_fiber_ = pac_thread_->owned_fiber();
							coroutine->switch_to_this();

							if (coroutine->is_waiting()) {

								coroutine_ref_queue_HIGH_.push(coroutine);

							}

						}



						/// schedules new job instance
						utilities::a_lref_t<job_coroutine> nextCoroutine;



						u32 job_queued_instance_count = job.queued_instance_count();
						while (!job.queued_instance_count_.compare_exchange_weak(job_queued_instance_count, job_queued_instance_count + 1));



						if (job_queued_instance_count >= job.instance_count_)
							continue;



						assert(coroutine_pool_.try_pop(nextCoroutine) && "ran out of coroutines.");



						nextCoroutine->bind_job(job);



						if (job_queued_instance_count < job.instance_count_) {

							coroutine_ref_queue_HIGH_.push(nextCoroutine);

						}

					}
					else
						break;

				}



				for (u32 i = 0; i < NCPP_DOP_JOB_NORMAL_STEP; ++i) {

					utilities::a_lref_t<job_coroutine> coroutine;



					if (pick_or_steal_coroutine_NORMAL(coroutine)) {



					}
					else
						break;

				}



				for (u32 i = 0; i < NCPP_DOP_JOB_LOW_STEP; ++i) {

					utilities::a_lref_t<job_coroutine> coroutine;



					if (pick_or_steal_coroutine_LOW(coroutine)) {



					}
					else
						break;

				}

			}

		}

		bool worker_thread::pick_or_steal_coroutine_HIGH(utilities::a_lref_t<job_coroutine>& coroutine) {

			bool hr = coroutine_ref_queue_HIGH_.try_pop(coroutine);

			if (hr) {

				if (coroutine.pointer() == 0) {

					std::cout << "error" << std::endl;

				}

			}
			else {



			}

			return hr;
		}
		bool worker_thread::pick_or_steal_coroutine_NORMAL(utilities::a_lref_t<job_coroutine>& coroutine) {

			bool hr = false;

			return hr;
		}
		bool worker_thread::pick_or_steal_coroutine_LOW(utilities::a_lref_t<job_coroutine>& coroutine) {

			bool hr = false;

			return hr;
		}



		void worker_thread::start() {

			if (is_main()) {

				worker_loop();

			}
			else {

				unique_pac_thread_ = std::move(
					pac::thread(
						[this]() {

							worker_loop();

						}
					)
				);

			}

		}
		void worker_thread::join() {

			if (index_ != 0) {

				pac_thread_->wait();

			}

		}

		void worker_thread::schedule(utilities::lref_t<job> job) {

			utilities::a_lref_t<job_coroutine> coroutine;



			u32 job_queued_instance_count = job->queued_instance_count();
			while (!job->queued_instance_count_.compare_exchange_weak(job_queued_instance_count, job_queued_instance_count + 1));



			if (job_queued_instance_count >= job->instance_count_) {

				return;
			}



			assert(coroutine_pool_.try_pop(coroutine) && "ran out of coroutines.");



			coroutine->bind_job(*job);

			switch (job->priority_)
			{
			case job_priority::HIGH:
				coroutine_ref_queue_HIGH_.push(coroutine);
				break;
			case job_priority::NORMAL:
				coroutine_ref_queue_NORMAL_.push(coroutine);
				break;
			case job_priority::LOW:
				coroutine_ref_queue_LOW_.push(coroutine);
				break;
			default:
				break;
			}

		}
#pragma endregion

#pragma endregion



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region CBJS

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

#pragma region CBJS Methods
		void cbjs::schedule(utilities::lref_t<job> job) {

			worker_thread& curr_wt = current_worker_thread();

			u8 curr_wt_index = curr_wt.index();



			for (u8 i = 0; i < job->batch_count(); ++i) {

				u8 wt_index = (curr_wt_index + i) % settings_.worker_thread_count;



				worker_thread& wt = *worker_thread_ptr_vector_[wt_index];



				wt.schedule(job);

			}

		}
#pragma endregion

#pragma endregion

	}

}