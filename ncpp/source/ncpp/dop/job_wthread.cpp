#include <ncpp/.hpp>



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {

	namespace dop {



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



		thread_local utilities::lref_t<job_wthread> current_wthread_g;
		job_wthread& current_wthread() {

			return *current_wthread_g;
		}

		thread_local utilities::lref_t<stack_heap_t<>> current_stack_heap_LARGE_g;
		thread_local utilities::lref_t<stack_heap_t<>> current_stack_heap_NORMAL_g;
		thread_local utilities::lref_t<stack_heap_t<>> current_stack_heap_SMALL_g;
		stack_heap_t<>& current_stack_heap_LARGE() {

			return *current_stack_heap_LARGE_g;
		}
		stack_heap_t<>& current_stack_heap_NORMAL() {

			return *current_stack_heap_NORMAL_g;
		}
		stack_heap_t<>& current_stack_heap_SMALL() {

			return *current_stack_heap_SMALL_g;
		}



		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



		job_wthread::job_wthread(
			u8 index,
			u32 job_handle_queue_capacity,
			u32 job_instance_pool_capacity,

			sz stack_heap_LARGE_stack_capacity,
			sz stack_heap_LARGE_stack_count,
			sz stack_heap_NORMAL_stack_capacity,
			sz stack_heap_NORMAL_stack_count,
			sz stack_heap_SMALL_stack_capacity,
			sz stack_heap_SMALL_stack_count
		) :
			index_(index),
			job_handle_queue_capacity_(job_handle_queue_capacity),
			job_instance_pool_capacity_(job_instance_pool_capacity),

			job_instance_ref_queue_(job_instance_pool_capacity, tgh_global_allocator_t<utilities::lref_t<job_instance>>()),

			stack_heap_LARGE_stack_capacity_(stack_heap_LARGE_stack_capacity),
			stack_heap_LARGE_stack_count_(stack_heap_LARGE_stack_count),
			stack_heap_NORMAL_stack_capacity_(stack_heap_NORMAL_stack_capacity),
			stack_heap_NORMAL_stack_count_(stack_heap_NORMAL_stack_count),
			stack_heap_SMALL_stack_capacity_(stack_heap_SMALL_stack_capacity),
			stack_heap_SMALL_stack_count_(stack_heap_SMALL_stack_count),

			stack_heap_LARGE_(stack_heap_LARGE_stack_capacity_, stack_heap_LARGE_stack_count_),
			stack_heap_NORMAL_(stack_heap_NORMAL_stack_capacity_, stack_heap_NORMAL_stack_count_),
			stack_heap_SMALL_(stack_heap_SMALL_stack_capacity_, stack_heap_SMALL_stack_count_)
		{

			job_instance_pool_ref_ = tgh_create_sys_lifetime_t<job_instance_pool>(
				*this,
				job_instance_pool_capacity_
			);

			scheduler_ref_ = tgh_create_sys_lifetime_t<job_wthread_scheduler>(
				*this,
				job_handle_queue_capacity
			);



			current_stack_heap_LARGE_g = stack_heap_LARGE_;
			current_stack_heap_NORMAL_g = stack_heap_NORMAL_;
			current_stack_heap_SMALL_g = stack_heap_SMALL_;

		}

		job_wthread::~job_wthread() {



		}

		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////

		void job_wthread::worker_loop() {

			/// setup
			current_wthread_g = *this;



			/// init job instance pool
			job_instance_pool_ref_->init();



			/// increase ready wthread count
			job_system::instance().ready_wthread_count_.fetch_add(1, std::memory_order_release);

			/// wait job system ready
			while (!job_system::instance().is_ready());



			if (index_ == 0) {

				/// schedule entry job
				job_system::instance().entry_job_handle_ref_ = schedule(job_system::instance().entry_job());

			}



			/// main loop
			while (job_system::instance().is_running()) {

				process_job_handles();
				process_job_instances();



				/// check if entry job was done
				if (index_ == 0)
				{

					if (job_system::instance().entry_job_handle_ref_->counter_ == 0) {

						job_system::instance().is_running_.store(false, std::memory_order_release);

					}

				}

			}

		}

		void job_wthread::init() {



		}

		bool job_wthread::try_make_job_instance(job_handle& handle) {

			u32 job_instance_index = 0;
				
			if (!handle.try_optain_instance_index(job_instance_index))
				return false;



			utilities::lref_t<job_instance> instance_ref;



			job_instance_pool_ref_->pop(instance_ref);



			instance_ref->setup_for_handle(handle, job_instance_index);

			job_instance_ref_queue_.push(instance_ref);



			return true;
		}

		void job_wthread::process_job_handles() {

			utilities::lref_t<job_handle> handle_ref;



			/// local job handle
			if (scheduler_ref_->try_pop_local(handle_ref)) {

				try_make_job_instance(*handle_ref);

			}



			/// shared job handle
			if (scheduler_ref_->try_pop_shared(handle_ref)) {

				try_make_job_instance(*handle_ref);

			}



			/// steal job handle
			if (scheduler_ref_->try_steal(handle_ref)) {

				try_make_job_instance(*handle_ref);

			}

		}
		void job_wthread::process_job_instances() {

			utilities::lref_t<job_instance> instance_ref;

			if (job_instance_ref_queue_.try_pop(instance_ref)) {

				if (instance_ref->is_waiting()) {

					job_instance_ref_queue_.push(instance_ref);

				}
				else {

					instance_ref->stack_allocator_.apply_native_use();
					instance_ref->switch_to_this();

					if (instance_ref->is_waiting()) {

						job_instance_ref_queue_.push(instance_ref);

					}

				}

				try_make_job_instance(*(instance_ref->handle_ref_));

			}

		}



		void job_wthread::run() {
			
			if (index_ != 0) {

				pac_thread_ref_ = tgh_create_sys_lifetime_t<pac::thread>(
					[&]() {

						worker_loop();

					}
				);

			}
			else {

				pac_thread_ref_ = pac::main_thread();

				worker_loop();

			}

		}
		void job_wthread::wait() {

			if(index_ != 0)
				pac_thread_ref_->wait();

		}

		job_handle& job_wthread::schedule(job& j) {

			return scheduler_ref_->schedule(j);
		}

	}

}