#pragma once

/**
 *  @file ncpp/containers/buffer.hpp
 *  @brief Implements buffer.
 */



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Includes

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/prerequisites.hpp>

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/utilities/.hpp>

#pragma endregion



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {

    namespace containers {



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        /**
         *  A buffer containing raw memory block allocated by an allocator 
         */
        template<class allocator_type__ = NCPP_DEFAULT_ALLOCATOR_TEMPLATE<u8>>
        class NCPP_DEFAULT_ALIGNAS buffer_t {

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Typedefs
        public:
            using allocator_type = rebind_allocator_t<allocator_type__, u8>;
            using item_vector_type = std::vector<u8, allocator_type>;
            using iterator = u8*;
            using const_iterator = const u8*;
#pragma endregion

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Properties
        private:
            allocator_type allocator_;
            iterator data_p_;
            sz size_;
#pragma endregion

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Getters and Setters
        public:
            inline allocator_type& allocator() { return allocator_; }
            inline const allocator_type& allocator() const { return allocator_; }

            inline iterator begin() { return data_p_; }
            inline const_iterator begin() const { return data_p_; }
            inline const_iterator cbegin() const { return data_p_; }
            inline iterator end() { return data_p_ + size_; }
            inline const_iterator end() const { return data_p_ + size_; }
            inline const_iterator cend() const { return data_p_ + size_; }

            inline iterator data_p() const { return data_p_; }
            inline sz size() const { return size_; }
#pragma endregion

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Constructors, Destructor and Operators
        public:
            /**
             *  Default constructor
             */
            inline explicit buffer_t() :
                allocator_(),
                data_p_(0),
                size_(0)
            {



            }
            /**
             *  Initialization constructor
             */
            inline explicit buffer_t(sz size) :
                buffer_t()
            {

                resize(size);

            }
            /**
             *  Initialization constructor with allocator
             */
            inline explicit buffer_t(const allocator_type& allocator) :
                allocator_(allocator),
                data_p_(0),
                size_(0)
            {



            }
            /**
             *  Initialization constructor with allocator and size
             */
            inline explicit buffer_t(sz size, const allocator_type& allocator) :
                buffer_t(allocator)
            {

                resize(size);

            }
            /**
             *  Destructor
             */
            ~buffer_t() {

                clear();

            }

            /**
             *  Copy constructor
             */
            inline buffer_t(const buffer_t& other) :
                buffer_t()
            {

                clear();

                allocator_ = other.allocator_;

                size_ = other.size_;

                if (size_ != 0) {

                    data_p_ = allocator_.allocate(size_);

                    memcpy(data_p_, other.data_p_, size_);

                }

            }
            /**
             *  Copy operator
             */
            inline buffer_t& operator = (const buffer_t& other) {

                clear();

                allocator_ = other.allocator_;

                size_ = other.size_;

                if (size_ != 0) {

                    data_p_ = allocator_.allocate(size_);

                    memcpy(data_p_, other.data_p_, size_);

                }

                return *this;
            }

            /**
             *  Move constructor
             */
            inline buffer_t(buffer_t&& other) :
                buffer_t()
            {

                clear();

                allocator_ = other.allocator_;
                data_p_ = other.data_p_;
                size_ = other.size_;

                other.data_p_ = 0;
                other.size_ = 0;

            }
            /**
             *  Move operator
             */
            inline buffer_t& operator = (buffer_t&& other) {

                clear();

                allocator_ = other.allocator_;
                data_p_ = other.data_p_;
                size_ = other.size_;

                other.data_p_ = 0;
                other.size_ = 0;

                return *this;
            }

#pragma endregion

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Methods
        private:
            template<typename item_param_type>
            inline void unsafe_set_main_t(sz offset, item_param_type&& item) {

                using parsed_type = std::remove_const_t<std::remove_reference_t<item_param_type>>;

                assert(
                    ((offset + sizeof(parsed_type)) <= size_)
                    && "buffer out of range"
                );

                *reinterpret_cast<parsed_type*>(data_p_ + offset) = std::forward<item_param_type>(item);

            }

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

        public:
            template<typename item_type, typename... arg_types__>
            inline void construct_t(sz offset, arg_types__&&... args) {

                new (reinterpret_cast<item_type*>(data_p_ + offset)) item_type(std::forward<arg_types__>(args)...);
            }

            template<typename item_type>
            inline void unsafe_set_t(sz offset, const item_type& item) {

                unsafe_set_main_t(offset, std::forward<const item_type&>(item));
            }
            template<typename item_type>
            inline void unsafe_set_t(sz offset, item_type&& item) {

                unsafe_set_main_t(offset, std::forward<item_type>(item));
            }

            template<typename item_type>
            inline void set_t(sz offset, const item_type& item) {

                construct_t<item_type>(offset);

                unsafe_set_main_t(offset, std::forward<const item_type&>(item));
            }
            template<typename item_type>
            inline void set_t(sz offset, item_type&& item) {

                construct_t<item_type>(offset);

                unsafe_set_main_t(offset, std::forward<item_type>(item));
            }

            template<typename item_type>
            inline item_type& get_t(sz offset) {

                assert(
                    ((offset + sizeof(item_type)) <= size_)
                    && "buffer out of range"
                );

                return *reinterpret_cast<item_type*>(data_p_ + offset);
            }
            template<typename item_type>
            inline const item_type& get_t(sz offset) const {

                assert(
                    ((offset + sizeof(item_type)) <= size_)
                    && "buffer out of range"
                );

                return *reinterpret_cast<item_type*>(data_p_ + offset);
            }

            inline void clear() {

                if (data_p_ != 0) {

                    allocator_.deallocate(data_p_);

                }

                size_ = 0;

            }
            inline void resize(sz size) {

                if (size == 0) {

                    clear();

                    return;
                }

                iterator new_data_p = allocator_.allocate(size);

                if (data_p_ != 0) {

                    memcpy(new_data_p, data_p_, (size_ > size) ? size : size_);

                    allocator_.deallocate(data_p_);

                }

                data_p_ = new_data_p;

                size_ = size;

            }
#pragma endregion

        };



        using buffer = buffer_t<>;

    }

}