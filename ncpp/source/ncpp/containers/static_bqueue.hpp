#pragma once

/**
 *  @file ncpp/containers/static_bqueue.hpp
 *  @brief Implements static buffer queue.
 */



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma region Includes

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/prerequisites.hpp>

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/utilities/.hpp>

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#include <ncpp/containers/fixed_buffer.hpp>

#pragma endregion



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace ncpp {

    namespace containers {



        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        /**
         *  A static_bqueue_t is a queue storing elements inside a fixed buffer
         */
        template<sz capacity__>
        class NCPP_DEFAULT_ALIGNAS static_bqueue_t {

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Typedefs
        public:
            using buffer_type = containers::fixed_buffer_t<capacity__>;
            using iterator = u8*;
            using const_iterator = const u8*;

            template<sz new_capacity__>
            using rebind_capacity_t = static_bqueue_t<new_capacity__>;
#pragma endregion

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Properties
        public:
            static constexpr i32 capacity() { return capacity__; };



        private:
            buffer_type buffer_;
            sz begin_index_;
            sz end_index_;
            sz last_index_;
#pragma endregion

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Getters and Setters
        public:
            inline iterator begin() { return buffer_.data_p() + begin_index_ % capacity(); }
            inline const_iterator begin() const { return buffer_.data_p() + begin_index_ % capacity(); }
            inline const_iterator cbegin() const { return buffer_.data_p() + begin_index_ % capacity(); }
            inline iterator end() { return buffer_.data_p() + end_index_ % capacity(); }
            inline const_iterator end() const { return buffer_.data_p() + end_index_ % capacity(); }
            inline const_iterator cend() const { return buffer_.data_p() + end_index_ % capacity(); }
            inline iterator last() { return buffer_.data_p() + last_index_ % capacity(); }
            inline const_iterator last() const { return buffer_.data_p() + last_index_ % capacity(); }

            inline sz size() const { return end_index_ - begin_index_; }
#pragma endregion

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Constructors, Destructor and Operators
        public:
            /**
             *  Default constructor
             */
            inline explicit static_bqueue_t() :
                begin_index_(capacity()),
                end_index_(capacity()),
                last_index_(capacity() - sizeof(sz))
            {

                buffer_.set_t<sz>(0, 0);

            }
            /**
             *  Destructor
             */
            ~static_bqueue_t() {



            }

            /**
             *  Copy constructor
             */
            inline static_bqueue_t(const static_bqueue_t& other)
            {

                buffer_ = other.buffer_;
                begin_index_ = other.begin_index_;
                end_index_ = other.end_index_;
                last_index_ = other.last_index_;

            }
            /**
             *  Copy operator
             */
            inline static_bqueue_t& operator = (const static_bqueue_t& other) {

                buffer_ = other.buffer_;
                begin_index_ = other.begin_index_;
                end_index_ = other.end_index_;
                last_index_ = other.last_index_;

                return *this;
            }

            /**
             *  Move constructor
             */
            inline static_bqueue_t(static_bqueue_t&& other)
            {

                buffer_ = other.buffer_;
                begin_index_ = other.begin_index_;
                end_index_ = other.end_index_;
                last_index_ = other.last_index_;
                other.clear();

            }
            /**
             *  Move operator
             */
            inline static_bqueue_t& operator = (static_bqueue_t&& other) {

                buffer_ = other.buffer_;
                begin_index_ = other.begin_index_;
                end_index_ = other.end_index_;
                last_index_ = other.last_index_;
                other.clear();

                return *this;
            }

#pragma endregion

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

#pragma region Methods
        private:
            template<typename item_param_type__>
            inline void push_main_t(item_param_type__&& item) {

                using parsed_type = std::remove_const_t<std::remove_reference_t<item_param_type__>>;

                constexpr sz block_size = sizeof(parsed_type) + sizeof(sz);

                assert((size() + block_size) <= capacity() && "bqueue out of range");



                sz last_offset = last_index_ % capacity();
                sz new_end_index = end_index_;
                sz current_offset = new_end_index % capacity();



                if (current_offset + block_size > capacity()) {

                    new_end_index += (current_offset + block_size) - capacity();

                    current_offset = 0;

                }



                if(end_index_ != begin_index_)
                    buffer_.unsafe_set_t<sz>(last_offset, current_offset);

                buffer_.unsafe_set_t<sz>(current_offset, current_offset + block_size);
                buffer_.set_t<parsed_type>(current_offset + sizeof(sz), std::forward<item_param_type__>(item));



                last_index_ = new_end_index;
                end_index_ = new_end_index + block_size;
                
            }

            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////

        public:
            template<typename item_type__>
            inline void push_t(item_type__&& item) {

                push_main_t(std::forward<item_type__>(item));
            }
            template<typename item_type__>
            inline void push(const item_type__& item) {

                push_main_t(item);
            }

            template<typename item_type__>
            inline b8 try_pop(item_type__& item_output) {

                if (size() == 0)
                    return false;

                sz begin_offset = begin_index_ % capacity();

                item_output = std::move(buffer_.get_t<item_type__>(begin_offset + sizeof(sz)));

                sz next_offset = buffer_.get_t<sz>(begin_offset);

                if (next_offset >= begin_offset)
                    begin_index_ += next_offset - begin_offset;
                else
                    begin_index_ += next_offset + capacity() - begin_offset;

                return true;
            }

            inline b8 try_pop() {

                if (size() == 0)
                    return false;

                sz begin_offset = begin_index_ % capacity();

                sz next_offset = buffer_.get_t<sz>(begin_offset);

                if (next_offset >= begin_offset)
                    begin_index_ += next_offset - begin_offset;
                else
                    begin_index_ += next_offset + capacity() - begin_offset;

                return true;
            }

            inline void pop() {

                assert(size() > 0);

                sz begin_offset = begin_index_ % capacity();

                sz next_offset = buffer_.get_t<sz>(begin_offset);

                if(next_offset >= begin_offset)
                    begin_index_ += next_offset - begin_offset;
                else
                    begin_index_ += next_offset + capacity() - begin_offset;

            }

            /**
             *  Clears the queue by resetting the end index and the begin index.
             */
            inline void clear() {

                begin_index_ = capacity();
                end_index_ = capacity();
                last_index_ = capacity() - sizeof(sz);

            }
#pragma endregion

        };

    }

}